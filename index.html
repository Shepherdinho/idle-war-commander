<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Idle War Commander - Core</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #121212;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  #gameContainer {
    display: flex;
    height: 100vh;
    width: 100vw;
  }
  #gameCanvas {
    background: #1b1b1b;
    flex: 3;
    display: block;
  }
  #uiPanel {
    flex: 1;
    background: #222;
    padding: 15px;
    box-sizing: border-box;
    overflow-y: auto;
  }
  h1, h2 {
    margin: 0 0 10px 0;
  }
  button {
    width: 100%;
    margin: 6px 0;
    padding: 10px;
    font-size: 1rem;
    background: #3a3a3a;
    border: none;
    color: #eee;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.3s;
  }
  button:hover:not(:disabled) {
    background: #4caf50;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  .stat {
    margin-bottom: 8px;
    font-size: 1.1rem;
  }
  #log {
    margin-top: 20px;
    height: 160px;
    overflow-y: auto;
    background: #111;
    padding: 8px;
    border-radius: 6px;
    font-size: 0.9rem;
    line-height: 1.2;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="uiPanel">
    <h1>Idle War Commander</h1>
    <div class="stat">Soldiers: <span id="soldiersCount">0</span></div>
    <div class="stat">Gold: <span id="goldCount">0</span></div>
    <div class="stat">Enemy Health: <span id="enemyHealth">100</span></div>
    <h2>Actions</h2>
    <button id="attackBtn" disabled>Attack Enemy (-5 Soldiers)</button>
    <button id="recruitBtn">Recruit Soldiers (+1 per 3 sec)</button>
    <h2>Upgrades</h2>
    <button id="upgradeRecruitBtn">Upgrade Recruitment (Cost: 50 Soldiers)</button>
    <button id="upgradeAttackBtn">Upgrade Attack Power (Cost: 75 Soldiers)</button>
    <button id="upgradeGoldBtn">Upgrade Gold Gain (Cost: 30 Gold)</button>
    <h2>Item Shop</h2>
    <button id="buyShieldBtn">Buy Shield (50 Gold)</button>
    <button id="buyMedicBtn">Buy Medic Tent (100 Gold)</button>
    <div id="log"></div>
  </div>
</div>

<script>
// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

// Game State
let soldiers = 0;
let gold = 0;
let enemyHealth = 100;
let maxEnemyHealth = 100;

let recruitRate = 1; // soldiers per interval
let recruitInterval = 3000; // 3 seconds

let attackPower = 10;
let goldGain = 1;

let shieldActive = false;
let medicActive = false;

let upgradeRecruitCost = 50;
let upgradeAttackCost = 75;
let upgradeGoldCost = 30;

// UI Elements
const soldiersCount = document.getElementById('soldiersCount');
const goldCount = document.getElementById('goldCount');
const enemyHealthEl = document.getElementById('enemyHealth');

const attackBtn = document.getElementById('attackBtn');
const recruitBtn = document.getElementById('recruitBtn');
const upgradeRecruitBtn = document.getElementById('upgradeRecruitBtn');
const upgradeAttackBtn = document.getElementById('upgradeAttackBtn');
const upgradeGoldBtn = document.getElementById('upgradeGoldBtn');
const buyShieldBtn = document.getElementById('buyShieldBtn');
const buyMedicBtn = document.getElementById('buyMedicBtn');
const logEl = document.getElementById('log');

// Timing control
let lastRecruitTime = 0;
let lastEnemyAttackTime = 0;
const enemyAttackInterval = 7000; // Enemy attacks roughly every 7 sec

// Animation Frames for soldiers and enemies
const soldierFrames = [];
const enemyFrames = [];
let soldierFrameIndex = 0;
let enemyFrameIndex = 0;

// Load images for animations
function loadImage(src) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.src = src;
  });
}

async function loadAssets() {
  // You can replace these URLs with your own sprites or sprite sheets
  // For now we load 4 frames each for soldiers and enemies for simple animation
  soldierFrames.push(await loadImage('https://i.imgur.com/zG7p3TG.png')); // soldier1
  soldierFrames.push(await loadImage('https://i.imgur.com/ooNxMPh.png')); // soldier2
  soldierFrames.push(await loadImage('https://i.imgur.com/fjFczJF.png')); // soldier3
  soldierFrames.push(await loadImage('https://i.imgur.com/txCZ0no.png')); // soldier4

  enemyFrames.push(await loadImage('https://i.imgur.com/dGkNaPc.png')); // enemy1
  enemyFrames.push(await loadImage('https://i.imgur.com/cvA4L4P.png')); // enemy2
  enemyFrames.push(await loadImage('https://i.imgur.com/t2V0zHf.png')); // enemy3
  enemyFrames.push(await loadImage('https://i.imgur.com/3Uy1cRz.png')); // enemy4
}

// Game Logs
function log(message) {
  const p = document.createElement('p');
  p.textContent = message;
  logEl.prepend(p);
  if (logEl.childNodes.length > 50) {
    logEl.removeChild(logEl.lastChild);
  }
}

// Update UI elements
function updateUI() {
  soldiersCount.textContent = soldiers;
  goldCount.textContent = gold;
  enemyHealthEl.textContent = enemyHealth;
  attackBtn.disabled = soldiers < 5 || enemyHealth <= 0;
  upgradeRecruitBtn.disabled = soldiers < upgradeRecruitCost;
  upgradeAttackBtn.disabled = soldiers < upgradeAttackCost;
  upgradeGoldBtn.disabled = gold < upgradeGoldCost;
  buyShieldBtn.disabled = gold < 50 || shieldActive;
  buyMedicBtn.disabled = gold < 100 || medicActive;
}

// Recruitment
function recruitSoldiers() {
  soldiers += recruitRate;
  log(`Recruited ${recruitRate} soldier(s). Total: ${soldiers}`);
}

// Attack Enemy
function attackEnemy() {
  if (soldiers < 5 || enemyHealth <= 0) return;
  soldiers -= 5;
  enemyHealth -= attackPower;

  log(`Attacked enemy for ${attackPower} damage. Enemy health: ${Math.max(enemyHealth, 0)}`);

  if (enemyHealth <= 0) {
    enemyHealth = 0;
    soldiers += 50;
    gold += 10 * goldGain;
    log(`Enemy defeated! Gained 50 soldiers and ${10 * goldGain} gold.`);
    enemyHealth = maxEnemyHealth;
  }

  updateUI();
}

// Enemy Attacks Soldiers
function enemyAttack() {
  if (soldiers <= 0) {
    log('Enemy attacks but you have no soldiers left!');
    return;
  }

  if (shieldActive) {
    shieldActive = false;
    log('Shield absorbed the enemy attack!');
    return;
  }

  let damage = Math.min(soldiers, Math.floor(Math.random() * 15) + 5);
  soldiers -= damage;
  log(`Enemy attacked! Lost ${damage} soldiers.`);

  if (medicActive) {
    let heal = Math.min(5, 100 - soldiers);
    soldiers += heal;
    log(`Medic Tent healed ${heal} soldiers.`);
  }

  updateUI();
}

// Upgrades
function upgradeRecruit() {
  if (soldiers >= upgradeRecruitCost) {
    soldiers -= upgradeRecruitCost;
    recruitRate++;
    upgradeRecruitCost = Math.floor(upgradeRecruitCost * 1.7);
    log('Recruitment rate upgraded!');
    updateUI();
  }
}

function upgradeAttack() {
  if (soldiers >= upgradeAttackCost) {
    soldiers -= upgradeAttackCost;
    attackPower += 5;
    upgradeAttackCost = Math.floor(upgradeAttackCost * 1.8);
    log('Attack power upgraded!');
    updateUI();
  }
}

function upgradeGold() {
  if (gold >= upgradeGoldCost) {
    gold -= upgradeGoldCost;
    goldGain++;
    upgradeGoldCost = Math.floor(upgradeGoldCost * 1.5);
    log('Gold gain upgraded!');
    updateUI();
  }
}

// Buy items
function buyShield() {
  if (gold >= 50 && !shieldActive) {
    gold -= 50;
    shieldActive = true;
    log('Shield purchased and activated!');
    updateUI();
  }
}

function buyMedic() {
  if (gold >= 100 && !medicActive) {
    gold -= 100;
    medicActive = true;
    log('Medic Tent purchased! Soldiers will heal after attacks.');
    updateUI();
  }
}

// Game Loop
let lastFrameTime = 0;
function gameLoop(timestamp) {
  if (!lastFrameTime) lastFrameTime = timestamp;
  let delta = timestamp - lastFrameTime;

  // Recruitment timing
  if (timestamp - lastRecruitTime > recruitInterval) {
    recruitSoldiers();
    lastRecruitTime = timestamp;
  }

  // Enemy attack timing
  if (timestamp - lastEnemyAttackTime > enemyAttackInterval) {
    enemyAttack();
    lastEnemy
// --- Continuation from previous code ---

  lastEnemyAttackTime = timestamp;
  }

  // Clear canvas for redraw
  ctx.clearRect(0, 0, width, height);

  // Draw background battlefield (simple grid)
  drawBattlefield();

  // Draw soldiers animation
  drawSoldiers();

  // Draw enemy animation
  drawEnemy();

  // Draw UI overlays or effects if needed
  drawEffects();

  // Update frame indices for animation
  updateAnimationFrames(delta);

  lastFrameTime = timestamp;
  requestAnimationFrame(gameLoop);
}

// Draw battlefield grid pattern
function drawBattlefield() {
  ctx.fillStyle = '#2a2a2a';
  ctx.fillRect(0, 0, width, height);

  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  const gridSize = 40;
  for(let x = 0; x < width; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, height);
    ctx.stroke();
  }
  for(let y = 0; y < height; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(width, y);
    ctx.stroke();
  }
}

// Draw soldiers sprites in formation on left side
function drawSoldiers() {
  const cols = 8;
  const spacingX = 50;
  const spacingY = 55;
  const startX = 50;
  const startY = height - 250;

  // Calculate how many soldiers to draw (max 40 for performance)
  const drawCount = Math.min(soldiers, 40);
  let frame = soldierFrames[soldierFrameIndex];

  for (let i = 0; i < drawCount; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    let x = startX + col * spacingX;
    let y = startY - row * spacingY;

    // Simple bobbing animation by offsetting y slightly based on frame
    let bobOffset = Math.sin(Date.now() / 200 + i) * 3;
    ctx.drawImage(frame, x, y + bobOffset, 40, 40);
  }
}

// Draw enemy sprites on right side with health bar
function drawEnemy() {
  const enemyX = width - 150;
  const enemyY = height - 280;
  let frame = enemyFrames[enemyFrameIndex];

  ctx.drawImage(frame, enemyX, enemyY, 80, 80);

  // Draw enemy health bar above enemy
  const barWidth = 120;
  const barHeight = 15;
  const healthRatio = enemyHealth / maxEnemyHealth;

  // Background bar
  ctx.fillStyle = '#550000';
  ctx.fillRect(enemyX - 20, enemyY - 25, barWidth, barHeight);

  // Health bar fill
  ctx.fillStyle = '#ff4444';
  ctx.fillRect(enemyX - 20, enemyY - 25, barWidth * healthRatio, barHeight);

  // Border
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(enemyX - 20, enemyY - 25, barWidth, barHeight);
}

// Optional visual effects placeholder
function drawEffects() {
  // For future flashes, explosions, or shield effect
  if (shieldActive) {
    // Draw glowing shield circle around soldiers
    ctx.save();
    ctx.strokeStyle = 'rgba(50, 200, 50, 0.7)';
    ctx.lineWidth = 6;
    ctx.shadowColor = '#0f0';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.ellipse(250, height - 170, 120, 80, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

// Animate frame cycling for soldiers and enemies
function updateAnimationFrames(delta) {
  // Change frames every 200ms
  if (!updateAnimationFrames.lastUpdate) updateAnimationFrames.lastUpdate = 0;

  updateAnimationFrames.lastUpdate += delta;
  if (updateAnimationFrames.lastUpdate > 200) {
    soldierFrameIndex = (soldierFrameIndex + 1) % soldierFrames.length;
    enemyFrameIndex = (enemyFrameIndex + 1) % enemyFrames.length;
    updateAnimationFrames.lastUpdate = 0;
  }
}

// Event listeners for buttons

attackBtn.addEventListener('click', () => {
  attackEnemy();
});

recruitBtn.addEventListener('click', () => {
  // Optional manual recruit +1
  soldiers++;
  log('Manually recruited 1 soldier.');
  updateUI();
});

upgradeRecruitBtn.addEventListener('click', () => {
  upgradeRecruit();
});

upgradeAttackBtn.addEventListener('click', () => {
  upgradeAttack();
});

upgradeGoldBtn.addEventListener('click', () => {
  upgradeGold();
});

buyShieldBtn.addEventListener('click', () => {
  buyShield();
});

buyMedicBtn.addEventListener('click', () => {
  buyMedic();
});

// Reset Game Button (added dynamically)
const resetBtn = document.createElement('button');
resetBtn.textContent = 'Reset Game';
resetBtn.style.marginTop = '20px';
resetBtn.style.background = '#cc4444';
resetBtn.style.color = '#fff';
resetBtn.addEventListener('click', () => {
  if(confirm('Are you sure you want to reset the game? All progress will be lost.')) {
    resetGame();
  }
});
document.getElementById('uiPanel').appendChild(resetBtn);

// Reset game function
function resetGame() {
  soldiers = 0;
  gold = 0;
  enemyHealth = maxEnemyHealth;
  recruitRate = 1;
  attackPower = 10;
  goldGain = 1;
  shieldActive = false;
  medicActive = false;
  upgradeRecruitCost = 50;
  upgradeAttackCost = 75;
  upgradeGoldCost = 30;
  logEl.innerHTML = '';
  log('Game reset.');
  updateUI();
}

// Initialize game assets then start
loadAssets().then(() => {
  log('Assets loaded. Starting game...');
  updateUI();
  enemyHealth = maxEnemyHealth;
  requestAnimationFrame(gameLoop);
}).catch(e => {
  log('Error loading assets: ' + e.message);
  alert('Failed to load game assets. Please refresh.');
});
// --- Extended game variables for advanced features ---

const enemyTypes = [
  {
    name: 'Goblin',
    maxHealth: 100,
    attackPower: 5,
    spriteUrls: [
      'https://i.imgur.com/QIGfVQa.gif',  // idle frames placeholder
      'https://i.imgur.com/zZQbC0U.gif',
    ],
  },
  {
    name: 'Orc',
    maxHealth: 300,
    attackPower: 15,
    spriteUrls: [
      'https://i.imgur.com/2M9aMgz.gif', // orc idle frame 1
      'https://i.imgur.com/Fo3XtNv.gif', // orc idle frame 2
    ],
  },
  {
    name: 'Troll',
    maxHealth: 800,
    attackPower: 40,
    spriteUrls: [
      'https://i.imgur.com/LU44Wjp.gif', // troll idle frame 1
      'https://i.imgur.com/R14tLJS.gif', // troll idle frame 2
    ],
  }
];

// Soldier classes with stats and images
const soldierClasses = {
  infantry: {
    name: 'Infantry',
    baseAttack: 10,
    baseDefense: 10,
    recruitCost: 1,  // soldiers needed to recruit 1 infantry
    spriteUrls: [
      'https://i.imgur.com/5W9kSfs.gif',
      'https://i.imgur.com/5W9kSfs2.gif',
    ]
  },
  archer: {
    name: 'Archer',
    baseAttack: 15,
    baseDefense: 5,
    recruitCost: 3,
    spriteUrls: [
      'https://i.imgur.com/BV06O9h.gif',
      'https://i.imgur.com/BV06O9h2.gif',
    ]
  },
  cavalry: {
    name: 'Cavalry',
    baseAttack: 25,
    baseDefense: 15,
    recruitCost: 5,
    spriteUrls: [
      'https://i.imgur.com/GFk73ro.gif',
      'https://i.imgur.com/GFk73ro2.gif',
    ]
  }
};

let currentEnemyIndex = 0;
let currentEnemy = null;

let soldierCountByClass = {
  infantry: 0,
  archer: 0,
  cavalry: 0,
};

let soldierSprites = {};
let enemySprites = [];

let recruitQueue = [];  // queue for soldiers to recruit over time

// Item system
const items = {
  shield: {
    name: 'Shield',
    costGold: 50,
    cooldownMs: 30000,
    active: false,
    lastUsed: 0,
    effect: function() {
      shieldActive = true;
      log('Shield activated! Next enemy attack absorbed.');
    }
  },
  medicTent: {
    name: 'Medic Tent',
    costGold: 100,
    cooldownMs: 60000,
    active: false,
    lastUsed: 0,
    effect: function() {
      medicActive = true;
      log('Medic tent deployed. Healing soldiers over time.');
    }
  }
};

// Save/load keys
const saveKey = 'idleWarCommanderSave';

// Initialize enemy sprites cache
async function loadEnemySprites() {
  for(let enemy of enemyTypes) {
    enemy.sprites = [];
    for(let url of enemy.spriteUrls) {
      const img = await loadImage(url);
      enemy.sprites.push(img);
    }
  }
}

// Initialize soldier sprites cache
async function loadSoldierSprites() {
  for(let key in soldierClasses) {
    soldierClasses[key].sprites = [];
    for(let url of soldierClasses[key].spriteUrls) {
      const img = await loadImage(url);
      soldierClasses[key].sprites.push(img);
    }
  }
}

// Helper function to load image
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error('Failed to load image: ' + src));
    img.src = src;
  });
}

// Spawn enemy function
function spawnEnemy(index) {
  currentEnemyIndex = index;
  currentEnemy = {
    type: enemyTypes[index],
    health: enemyTypes[index].maxHealth,
    maxHealth: enemyTypes[index].maxHealth,
    attackPower: enemyTypes[index].attackPower,
    frameIndex: 0,
    frameElapsed: 0,
  };
  enemyFrames = currentEnemy.type.sprites;
  enemyFrameIndex = 0;
  maxEnemyHealth = currentEnemy.maxHealth;
  log(`Enemy Spawned: ${currentEnemy.type.name} (HP: ${currentEnemy.maxHealth})`);
}

// Recruit soldier class function (queues recruitment)
function recruitSoldierClass(className, amount = 1) {
  if (!soldierClasses[className]) return false;
  let cost = soldierClasses[className].recruitCost * amount;
  if (soldiers < cost) {
    log(`Not enough soldiers to recruit ${amount} ${className}(s).`);
    return false;
  }
  soldiers -= cost;
  for(let i = 0; i < amount; i++) {
    recruitQueue.push(className);
  }
  log(`Queued recruitment of ${amount} ${className}(s).`);
  updateUI();
  return true;
}

// Process recruit queue gradually
function processRecruitQueue() {
  if (recruitQueue.length > 0) {
    // Recruit 1 soldier per tick
    let className = recruitQueue.shift();
    soldierCountByClass[className]++;
    log(`Recruited 1 ${className}. Total: ${soldierCountByClass[className]}`);
    updateUI();
  }
}

// Calculate total soldier attack power dynamically
function calculateTotalAttackPower() {
  let total = 0;
  for(let key in soldierCountByClass) {
    total += soldierCountByClass[key] * soldierClasses[key].baseAttack;
  }
  return total + attackPower;
}

// Enemy AI attack
function enemyAttack() {
  if (!currentEnemy) return;

  let now = Date.now();
  if (now - lastEnemyAttackTime < 3000) return; // 3 sec cooldown

  lastEnemyAttackTime = now;

  if (shieldActive) {
    shieldActive = false;
    log('Shield absorbed enemy attack!');
    return;
  }

  // Calculate damage to soldiers
  let damage = currentEnemy.attackPower;

  // Simple defense: subtract average soldier defense
  let totalDefense = 0;
  for(let key in soldierCountByClass) {
    totalDefense += soldierCountByClass[key] * soldierClasses[key].baseDefense;
  }
  let totalSoldiers = Object.values(soldierCountByClass).reduce((a,b)=>a+b,0);

  let avgDefense = totalSoldiers > 0 ? totalDefense / totalSoldiers : 0;
  let netDamage = Math.max(0, damage - avgDefense);

  if (netDamage > 0 && totalSoldiers > 0) {
    // Remove soldiers proportionally from classes
    for(let key in soldierCountByClass) {
      if (soldierCountByClass[key] > 0) {
        let loss = Math.min(soldierCountByClass[key], Math.ceil(netDamage * soldierCountByClass[key] / totalSoldiers));
        soldierCountByClass[key] -= loss;
        log(`Enemy attack! Lost ${loss} ${key}(s).`);
      }
    }
  } else {
    log('Enemy attack blocked by soldier defenses.');
  }

  updateUI();
}

// Player attacks enemy
function playerAttack() {
  let totalAttack = calculateTotalAttackPower();

  currentEnemy.health -= totalAttack;

  log(`You attacked enemy for ${totalAttack} damage!`);

  if (currentEnemy.health <= 0) {
    enemyDefeated();
  }

  updateUI();
}

// Enemy defeated handler
function enemyDefeated() {
  log(`Enemy ${currentEnemy.type.name} defeated!`);
  gold += currentEnemy.type.maxHealth / 10 * goldGain;
  soldiers += 10 * recruitRate;

  // Advance to next enemy or loop back
  currentEnemyIndex++;
  if (currentEnemyIndex >= enemyTypes.length) {
    currentEnemyIndex = 0;
  }
  spawnEnemy(currentEnemyIndex);
  updateUI();
}

// Item purchase handler
function buyItem(itemName) {
  if (!items[itemName]) return;
  let item = items[itemName];
  if (gold < item.costGold) {
    log(`Not enough gold to buy ${item.name}.`);
    return false;
  }
  if (Date.now() - item.lastUsed < item.cooldownMs) {
    log(`${item.name} is on cooldown.`);
    return false;
  }
  gold -= item.costGold;
  item.lastUsed = Date.now();
  item.effect();
  updateUI();
  return true;
}

// Save game state to localStorage
function saveGame() {
  let state = {
    soldiers,
    soldierCountByClass,
    gold,
    currentEnemyIndex,
    currentEnemyHealth: currentEnemy ? currentEnemy.health : maxEnemyHealth,
    recruitRate,
    attackPower,
    goldGain,
    shieldActive,
    medicActive,
    recruitQueue,
    lastSave: Date.now(),
  };
  localStorage.setItem(saveKey, JSON.stringify(state));
  log('Game saved.');
}

// Load game state from localStorage
function loadGame() {
  let stateStr = localStorage.getItem(saveKey);
  if (!stateStr) {
    log('No saved game found.');
    return false;
  }
  try {
    let state = JSON.parse(stateStr);
    soldiers = state.soldiers || 0;
    soldierCountByClass = state.soldierCountByClass || { infantry:0, archer:0, cavalry:0 };
    gold = state.gold || 0;
    currentEnemyIndex = state.currentEnemyIndex || 0;
    recruitRate = state.recruitRate || 1;
    attackPower = state.attackPower || 10;
    goldGain = state.goldGain || 1;
    shieldActive = state.shieldActive || false;
    medicActive = state.medicActive || false;
    recruitQueue = state.recruitQueue || [];
    spawnEnemy(currentEnemyIndex);
    currentEnemy.health = state.currentEnemyHealth || currentEnemy.maxHealth;
    updateUI();
    log('Game loaded.');
    return true;
  } catch (e) {
    log('Failed to load saved game.');
    return false;
  }
}

// Game tick to update state every 5 seconds
function gameTick() {
  soldiers += recruitRate;
  if (medicActive) {
    soldiers += 2; // Medic heals 2 soldiers per tick
    log('Medic healed 2 soldiers.');
  }
  processRecruitQueue();
  enemyAttack();

  saveGame();

  updateUI();
}

// Set game tick interval
setInterval(gameTick, recruitIntervalMs);

// UI Setup for soldier classes recruit buttons
function setupSoldierClassUI() {
  const container = document.getElementById('soldierClassButtons');
  if (!container) return;
  container.innerHTML = ''; // clear existing buttons

  for (let key in soldierClasses) {
    const btn = document.createElement('button');
    btn.textContent = `Recruit ${soldierClasses[key].name} (Cost: ${soldierClasses[key
// --- Continuing soldier recruit buttons creation ---

    recruitCost})`;
    btn.onclick = () => {
      recruitSoldierClass(key, 1);
    };
    container.appendChild(btn);
  }
}

// Animate enemy sprite frames for idle animation
function animateEnemySprite(deltaTime) {
  if (!currentEnemy) return;
  currentEnemy.frameElapsed += deltaTime;
  if (currentEnemy.frameElapsed > 500) { // switch frame every 0.5 seconds
    currentEnemy.frameIndex = (currentEnemy.frameIndex + 1) % currentEnemy.type.sprites.length;
    currentEnemy.frameElapsed = 0;
  }
}

// Animate soldier sprites for idle animation
function animateSoldierSprites(deltaTime) {
  for (let key in soldierCountByClass) {
    if (!soldierClasses[key].frameElapsed) soldierClasses[key].frameElapsed = 0;
    if (!soldierClasses[key].frameIndex) soldierClasses[key].frameIndex = 0;
    soldierClasses[key].frameElapsed += deltaTime;
    if (soldierClasses[key].frameElapsed > 700) { // switch frame every 0.7 seconds
      soldierClasses[key].frameIndex = (soldierClasses[key].frameIndex + 1) % soldierClasses[key].sprites.length;
      soldierClasses[key].frameElapsed = 0;
    }
  }
}

// Draw function to render game elements on canvas
function drawGame() {
  const canvas = document.getElementById('gameCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw enemy
  if (currentEnemy && currentEnemy.type.sprites.length > 0) {
    let sprite = currentEnemy.type.sprites[currentEnemy.frameIndex];
    ctx.drawImage(sprite, canvas.width/2 - sprite.width/2, 50);
  }

  // Draw enemy health bar
  if (currentEnemy) {
    const barWidth = 300;
    const barHeight = 20;
    const x = canvas.width/2 - barWidth/2;
    const y = 20;

    ctx.fillStyle = 'gray';
    ctx.fillRect(x, y, barWidth, barHeight);

    const healthPercent = Math.max(0, currentEnemy.health / currentEnemy.maxHealth);
    ctx.fillStyle = 'red';
    ctx.fillRect(x, y, barWidth * healthPercent, barHeight);

    ctx.strokeStyle = 'black';
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.fillText(`${currentEnemy.type.name} HP: ${Math.floor(currentEnemy.health)} / ${currentEnemy.maxHealth}`, x + 10, y + 15);
  }

  // Draw soldiers count and sprites
  let baseY = canvas.height - 150;
  let startX = 50;
  let spacingX = 150;
  let idx = 0;
  ctx.font = '18px Arial';

  for (let key in soldierCountByClass) {
    let count = soldierCountByClass[key];
    if (count > 0 && soldierClasses[key].sprites.length > 0) {
      let spriteIndex = soldierClasses[key].frameIndex || 0;
      let sprite = soldierClasses[key].sprites[spriteIndex];
      let x = startX + spacingX * idx;
      let y = baseY;

      ctx.drawImage(sprite, x, y);

      ctx.fillStyle = 'black';
      ctx.fillText(`${soldierClasses[key].name}: ${count}`, x, y + sprite.height + 20);
    }
    idx++;
  }

  // Draw gold and soldiers text
  ctx.fillStyle = 'black';
  ctx.font = '22px Arial';
  ctx.fillText(`Gold: ${Math.floor(gold)}`, 20, 40);
  ctx.fillText(`Soldiers (total): ${getTotalSoldiers()}`, 20, 70);

  // Draw recruit queue
  ctx.font = '16px Arial';
  ctx.fillStyle = 'darkblue';
  ctx.fillText(`Recruit Queue: ${recruitQueue.length}`, 20, 100);

  // Draw item cooldowns
  let itemX = canvas.width - 150;
  let itemY = 40;
  for (let key in items) {
    let item = items[key];
    ctx.fillStyle = 'black';
    ctx.fillText(`${item.name}`, itemX, itemY);

    let cooldownLeft = Math.max(0, item.cooldownMs - (Date.now() - item.lastUsed));
    if (cooldownLeft > 0) {
      ctx.fillStyle = 'red';
      ctx.fillText(`Cooldown: ${(cooldownLeft / 1000).toFixed(1)}s`, itemX, itemY + 20);
    } else {
      ctx.fillStyle = 'green';
      ctx.fillText(`Ready!`, itemX, itemY + 20);
    }

    itemY += 50;
  }
}

// Helper to get total soldiers count
function getTotalSoldiers() {
  return Object.values(soldierCountByClass).reduce((a, b) => a + b, 0);
}

// Game loop using requestAnimationFrame
let lastTime = 0;
function gameLoop(time = 0) {
  const deltaTime = time - lastTime;
  lastTime = time;

  animateEnemySprite(deltaTime);
  animateSoldierSprites(deltaTime);
  drawGame();

  requestAnimationFrame(gameLoop);
}

// Start game loop
requestAnimationFrame(gameLoop);

// Log messages to a dedicated UI element
function log(message) {
  const logArea = document.getElementById('logArea');
  if (!logArea) return;
  let p = document.createElement('p');
  p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
  logArea.appendChild(p);
  logArea.scrollTop = logArea.scrollHeight;
}

// Setup item purchase buttons UI
function setupItemButtons() {
  const container = document.getElementById('itemButtons');
  if (!container) return;
  container.innerHTML = '';
  for (let key in items) {
    let item = items[key];
    let btn = document.createElement('button');
    btn.textContent = `Buy ${item.name} (${item.costGold} gold)`;
    btn.onclick = () => buyItem(key);
    container.appendChild(btn);
  }
}

// Upgrade system - simple upgrades for attackPower, recruitRate, goldGain

const upgrades = {
  attackPower: {
    level: 0,
    baseCost: 100,
    increment: 20,
    maxLevel: 10,
    applyUpgrade: () => {
      attackPower += 5;
    }
  },
  recruitRate: {
    level: 0,
    baseCost: 150,
    increment: 30,
    maxLevel: 10,
    applyUpgrade: () => {
      recruitRate += 1;
    }
  },
  goldGain: {
    level: 0,
    baseCost: 120,
    increment: 25,
    maxLevel: 10,
    applyUpgrade: () => {
      goldGain += 0.5;
    }
  }
};

// Purchase upgrade function
function buyUpgrade(upgradeKey) {
  let upg = upgrades[upgradeKey];
  if (!upg) return false;
  if (upg.level >= upg.maxLevel) {
    log(`${upgradeKey} upgrade is maxed out.`);
    return false;
  }
  let cost = upg.baseCost + upg.level * upg.increment;
  if (gold < cost) {
    log(`Not enough gold to upgrade ${upgradeKey}. Need ${cost} gold.`);
    return false;
  }
  gold -= cost;
  upg.level++;
  upg.applyUpgrade();
  log(`Upgraded ${upgradeKey} to level ${upg.level}.`);
  updateUI();
  return true;
}

// Setup upgrade buttons UI
function setupUpgradeButtons() {
  const container = document.getElementById('upgradeButtons');
  if (!container) return;
  container.innerHTML = '';

  for (let key in upgrades) {
    let upg = upgrades[key];
    let btn = document.createElement('button');
    let cost = upg.baseCost + upg.level * upg.increment;
    btn.textContent = `${key} Upgrade (Lvl ${upg.level}) - Cost: ${cost} gold`;
    btn.onclick = () => buyUpgrade(key);
    container.appendChild(btn);
  }
}

// Update UI elements with current game data
function updateUI() {
  // Update soldiers total display
  const soldierCountText = document.getElementById('soldierCountText');
  if (soldierCountText) soldierCountText.textContent = `Soldiers: ${getTotalSoldiers()}`;

  // Update gold display
  const goldCountText = document.getElementById('goldCountText');
  if (goldCountText) goldCountText.textContent = `Gold: ${Math.floor(gold)}`;

  // Update recruit queue count
  const recruitQueueText = document.getElementById('recruitQueueText');
  if (recruitQueueText) recruitQueueText.textContent = `Recruit Queue: ${recruitQueue.length}`;

  // Update upgrade buttons UI cost and labels
  setupUpgradeButtons();
}

// Attach UI button handlers for player attack and recruit soldier mass
document.getElementById('attackEnemyBtn').onclick = playerAttack;
document.getElementById('recruitInfantryBtn').onclick = () => recruitSoldierClass('infantry', 5);
document.getElementById('recruitArcherBtn').onclick = () => recruitSoldierClass('archer', 3);
document.getElementById('recruitCavalryBtn').onclick = () => recruitSoldierClass('cavalry', 2);

setupSoldierClassUI();
setupItemButtons();
setupUpgradeButtons();

spawnEnemy(currentEnemyIndex);
updateUI();

// Sound effects - placeholder
const soundEffects = {
  attack: new Audio('https://actions.google.com/sounds/v1/impacts/metal_thud_and_wood_plank.ogg'),
  enemyDefeated: new Audio('https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg'),
  recruit: new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg')
};

function playSound(name) {
  if (soundEffects[name]) {
    soundEffects[name].currentTime = 0;
    soundEffects[name].play();
  }
}

// Override playerAttack to play sound
function playerAttack() {
  let totalAttack = calculateTotalAttackPower();

  if (!currentEnemy) return;

  currentEnemy.health -= totalAttack;
  log(`You attacked enemy for ${totalAttack} damage!`);
  playSound('attack');

  if (currentEnemy.health <= 0) {
    playSound('enemyDefeated');
    enemyDefeated();
  }

  updateUI();
}

// Override recruitSoldierClass to play recruit sound
function recruitSoldierClass(className, amount = 1) {
  if (!soldierClasses[className]) return false;
  let cost = soldierClasses[className].recruitCost * amount;
  if (soldiers < cost) {
    log(`Not enough soldiers to recruit ${amount} ${className}(s).`);
    return false;
  }
  soldiers -= cost;
  for(let i = 0; i < amount; i++) {
    recruitQueue.push(className);
  }
  log(`Queued recruitment of ${amount} ${className}(s).`);
  playSound('recruit');
  updateUI();
  return true;
}

// Initialize save/load buttons UI and handlers
document.getElementById('saveGameBtn').onclick = saveGame;
document.getElementById('loadGameBtn').onclick = loadGame;
// ========================
// Quest and Mission System
// ========================

const quests = [
  {
    id: 1,
    name: "First Blood",
    description: "Defeat your first enemy.",
    completed: false,
    condition: () => enemyDefeatedCount >= 1,
    reward: () => {
      gold += 100;
      log("Quest Reward: 100 Gold!");
      updateUI();
    }
  },
  {
    id: 2,
    name: "Recruiter",
    description: "Recruit 50 soldiers total.",
    completed: false,
    condition: () => getTotalSoldiers() >= 50,
    reward: () => {
      gold += 200;
      recruitRate += 2;
      log("Quest Reward: 200 Gold + Recruit Rate +2");
      updateUI();
    }
  },
  {
    id: 3,
    name: "Elite Force",
    description: "Recruit at least 10 Cavalry soldiers.",
    completed: false,
    condition: () => soldierCountByClass['cavalry'] >= 10,
    reward: () => {
      gold += 300;
      attackPower += 10;
      log("Quest Reward: 300 Gold + Attack Power +10");
      updateUI();
    }
  }
];

// Track quests progress globally
let activeQuests = quests.slice();
let completedQuests = [];

// Called periodically to check quest completion
function checkQuests() {
  for (let q of activeQuests) {
    if (!q.completed && q.condition()) {
      q.completed = true;
      q.reward();
      log(`Quest Completed: ${q.name}`);
      completedQuests.push(q);
    }
  }
  // Remove completed quests from active
  activeQuests = activeQuests.filter(q => !q.completed);
  updateQuestUI();
}

// Render quest UI list
function updateQuestUI() {
  const questContainer = document.getElementById('questList');
  if (!questContainer) return;
  questContainer.innerHTML = '';

  if (activeQuests.length === 0) {
    questContainer.textContent = "No active quests.";
    return;
  }

  for (let q of activeQuests) {
    let div = document.createElement('div');
    div.className = 'quest-item';
    div.textContent = `${q.name}: ${q.description}`;
    questContainer.appendChild(div);
  }
}

// =======================
// Achievements System
// =======================

const achievements = [
  {
    id: 1,
    name: "Warrior Novice",
    description: "Attack 100 times.",
    unlocked: false,
    condition: () => attackCount >= 100,
    reward: () => {
      gold += 500;
      log("Achievement Unlocked: Warrior Novice (+500 Gold)");
      updateUI();
    }
  },
  {
    id: 2,
    name: "Millionaire",
    description: "Accumulate 1,000,000 gold total.",
    unlocked: false,
    condition: () => totalGoldEarned >= 1000000,
    reward: () => {
      recruitRate += 5;
      log("Achievement Unlocked: Millionaire (+5 Recruit Rate)");
      updateUI();
    }
  }
];

let activeAchievements = achievements.slice();
let unlockedAchievements = [];

// Check and unlock achievements
function checkAchievements() {
  for (let ach of activeAchievements) {
    if (!ach.unlocked && ach.condition()) {
      ach.unlocked = true;
      ach.reward();
      log(`Achievement Unlocked: ${ach.name}`);
      unlockedAchievements.push(ach);
    }
  }
  activeAchievements = activeAchievements.filter(a => !a.unlocked);
  updateAchievementUI();
}

function updateAchievementUI() {
  const achContainer = document.getElementById('achievementList');
  if (!achContainer) return;
  achContainer.innerHTML = '';

  if (unlockedAchievements.length === 0) {
    achContainer.textContent = "No achievements unlocked yet.";
    return;
  }

  for (let a of unlockedAchievements) {
    let div = document.createElement('div');
    div.className = 'achievement-item';
    div.textContent = `${a.name}: ${a.description}`;
    achContainer.appendChild(div);
  }
}

// ============================
// Prestige / Reset System
// ============================

let prestigePoints = 0;

// Calculate prestige points based on progress (e.g., total gold earned)
function calculatePrestigePoints() {
  // For every 100k gold earned, 1 prestige point
  return Math.floor(totalGoldEarned / 100000);
}

// Prestige reset function to reset progress for permanent bonuses
function prestigeReset() {
  let points = calculatePrestigePoints();
  if (points <= prestigePoints) {
    log("Not enough progress to gain more prestige points.");
    return;
  }
  let gained = points - prestigePoints;
  prestigePoints = points;
  log(`Prestige Reset! You gained ${gained} prestige points.`);

  // Reset core game variables but keep prestige bonuses
  gold = 0;
  soldiers = 0;
  soldierCountByClass = { infantry: 0, archer: 0, cavalry: 0 };
  recruitQueue = [];
  currentEnemyIndex = 0;
  enemyDefeatedCount = 0;
  attackCount = 0;
  totalGoldEarned = 0;

  attackPower = 10 + prestigePoints * 5; // Each prestige point adds attack
  recruitRate = 1 + prestigePoints * 1; // Each prestige point adds recruit rate
  goldGain = 1 + prestigePoints * 0.5;

  // Reset upgrades too
  for (let key in upgrades) {
    upgrades[key].level = 0;
  }

  activeQuests = quests.slice();
  completedQuests = [];
  activeAchievements = achievements.slice();
  unlockedAchievements = [];

  spawnEnemy(currentEnemyIndex);
  updateUI();
  updateQuestUI();
  updateAchievementUI();
}

// Attach prestige button
document.getElementById('prestigeBtn').onclick = prestigeReset;

// ================================
// Feedback Animations & Effects
// ================================

const feedbackMessages = [];

function addFeedback(message, x, y, color = 'yellow') {
  feedbackMessages.push({
    message,
    x,
    y,
    alpha: 1.0,
    color,
    lifespan: 1000, // ms
    created: Date.now()
  });
}

// Draw feedback animations on canvas
function drawFeedback(ctx) {
  const now = Date.now();
  feedbackMessages.forEach((fb, index) => {
    let elapsed = now - fb.created;
    if (elapsed > fb.lifespan) {
      feedbackMessages.splice(index, 1);
      return;
    }
    fb.alpha = 1 - elapsed / fb.lifespan;
    ctx.save();
    ctx.globalAlpha = fb.alpha;
    ctx.fillStyle = fb.color;
    ctx.font = '20px Arial';
    ctx.fillText(fb.message, fb.x, fb.y - (elapsed / 10));
    ctx.restore();
  });
}

// Extend drawGame to call drawFeedback
const originalDrawGame = drawGame;
drawGame = function() {
  originalDrawGame();

  const canvas = document.getElementById('gameCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  drawFeedback(ctx);
};

// Add feedback when attacking or recruiting
function playerAttack() {
  let totalAttack = calculateTotalAttackPower();

  if (!currentEnemy) return;

  currentEnemy.health -= totalAttack;
  addFeedback(`-${totalAttack}`, 400, 150, 'red');
  log(`You attacked enemy for ${totalAttack} damage!`);
  playSound('attack');

  attackCount++;
  totalGoldEarned += 0; // No gold on attack, but track totalGoldEarned elsewhere

  if (currentEnemy.health <= 0) {
    playSound('enemyDefeated');
    enemyDefeated();
  }

  checkQuests();
  checkAchievements();
  updateUI();
}

function recruitSoldierClass(className, amount = 1) {
  if (!soldierClasses[className]) return false;
  let cost = soldierClasses[className].recruitCost * amount;
  if (soldiers < cost) {
    log(`Not enough soldiers to recruit ${amount} ${className}(s).`);
    return false;
  }
  soldiers -= cost;
  for(let i = 0; i < amount; i++) {
    recruitQueue.push(className);
  }
  addFeedback(`+${amount} ${className}`, 150, 550, 'limegreen');
  log(`Queued recruitment of ${amount} ${className}(s).`);
  playSound('recruit');
  updateUI();
  return true;
}

// =========================
// Auto Save / Auto Load
// =========================

let autoSaveInterval = 60000; // 1 minute

function autoSaveGame() {
  saveGame();
  log("Game auto-saved.");
}

setInterval(autoSaveGame, autoSaveInterval);

// =========================
// UI Helpers and Setup
// =========================

// Populate the quest, achievement, and prestige UI containers
function setupUI() {
  updateQuestUI();
  updateAchievementUI();

  // Prestige points display
  const prestigeDisplay = document.getElementById('prestigePoints');
  if (prestigeDisplay) {
    prestigeDisplay.textContent = `Prestige Points: ${prestigePoints}`;
  }
}

setupUI();

// =====================
// Enemy AI Behavior
// =====================

// Enemy attack damage calculation with randomness and scaling
function enemyAttack() {
  if (!currentEnemy) return;
  let baseDamage = currentEnemy.type.attackPower;
  let damage = baseDamage + Math.floor(Math.random() * 5);
  // Reduce soldiers as damage taken
  let soldiersLost = Math.min(getTotalSoldiers(), Math.floor(damage / 2));
  if (soldiersLost > 0) {
    // Remove soldiers proportionally from classes
    for (let key in soldierCountByClass) {
      if (soldiersLost <= 0) break;
      let count = soldierCountByClass[key];
      if (count <= 0) continue;
      let removeCount = Math.min(count, soldiersLost);
      soldierCountByClass[key] -= removeCount;
      soldiersLost -= removeCount;
    }
    log(`Enemy attacked and you lost ${Math.floor(damage/2)} soldiers.`);
    addFeedback(`-${Math.floor(damage/2)} Soldiers Lost`, 150, 580, 'orange');
  } else {
    log("Enemy attacked but you have no soldiers lost.");
  }
  updateUI();
}

// Enemy attacks every X seconds, scaled by enemy level
let enemyAttackInterval = 7000;

setInterval(() => {
  if (currentEnemy && !currentEnemy.health <= 0) {
    enemyAttack();
  }
}, enemyAttackInterval);

// ======================
// Debug / Dev Commands
// ======================

window.devCheats = {
  addGold: (amount) => {
    gold += amount;
    totalGoldEarned += amount;
    log(`Cheat: Added ${amount} gold.`);
    updateUI();
  },
  addSoldiers: (amount) => {
    soldiers += amount;
    log(`Cheat: Added ${amount} soldiers.`);
    updateUI();
  },
  killEnemy: () => {
    if (currentEnemy) {
      currentEnemy.health = 0;
      enemyDefeated();
      log("Cheat: Enemy killed.");
    }
  },
  prestige: () => {
    prestigeReset();
  }
};

log("Dev Cheats available: devCheats.addGold(amount), devCheats.addSoldiers(amount), devCheats.killEnemy(), devCheats.prestige()");

// =======================
// Misc Utility Functions
// =======================

// Format large numbers with commas
function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// Clamp number between min and max
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}

// =======================
// Game Initialization
// =======================

// Run on page load or game start
function initGame() {
  spawnEnemy(currentEnemyIndex);
  updateUI();
  setupUI();
  setupSoldierClassUI();
  setupItemButtons();
  setupUpgradeButtons();
  log("Game Initialized.");
}

window.onload = initGame;
// ========================
// Item & Gear System Setup
// ========================

// Define item types
const itemTypes = {
  weapon: 'weapon',
  armor: 'armor',
  accessory: 'accessory'
};

// Example item database
const itemDatabase = [
  {
    id: 1,
    name: "Iron Sword",
    type: itemTypes.weapon,
    attackBonus: 10,
    defenseBonus: 0,
    rarity: "common",
    craftingMaterials: { iron: 5, wood: 2 },
    description: "Basic iron sword that adds +10 attack."
  },
  {
    id: 2,
    name: "Steel Shield",
    type: itemTypes.armor,
    attackBonus: 0,
    defenseBonus: 15,
    rarity: "uncommon",
    craftingMaterials: { steel: 10, leather: 5 },
    description: "Shield that increases defense by 15."
  },
  {
    id: 3,
    name: "Ring of Swiftness",
    type: itemTypes.accessory,
    attackBonus: 5,
    defenseBonus: 5,
    rarity: "rare",
    craftingMaterials: { gold: 2, gem: 1 },
    description: "Accessory that boosts attack and defense by 5."
  }
];

// Player inventory and equipped gear
let playerInventory = [];
let equippedGear = {
  weapon: null,
  armor: null,
  accessory: null
};

// Crafting materials player owns
let craftingMaterials = {
  iron: 20,
  wood: 10,
  steel: 15,
  leather: 10,
  gold: 5,
  gem: 2
};

// =========================
// Crafting System Functions
// =========================

// Check if player has materials to craft item
function canCraft(item) {
  if (!item.craftingMaterials) return false;
  for (let mat in item.craftingMaterials) {
    if ((craftingMaterials[mat] || 0) < item.craftingMaterials[mat]) {
      return false;
    }
  }
  return true;
}

// Craft item: consume materials and add to inventory
function craftItem(itemId) {
  let item = itemDatabase.find(i => i.id === itemId);
  if (!item) {
    log("Item not found.");
    return false;
  }
  if (!canCraft(item)) {
    log("Not enough materials to craft " + item.name);
    return false;
  }
  // Consume materials
  for (let mat in item.craftingMaterials) {
    craftingMaterials[mat] -= item.craftingMaterials[mat];
  }
  // Add item to inventory
  playerInventory.push(item);
  log(`Crafted item: ${item.name}`);
  updateInventoryUI();
  updateMaterialsUI();
  return true;
}

// =======================
// Equipment Management
// =======================

// Equip item by type; returns false if invalid
function equipItem(itemId) {
  let item = playerInventory.find(i => i.id === itemId);
  if (!item) {
    log("Item not found in inventory.");
    return false;
  }
  let slot = item.type;
  if (!slot) {
    log("Item has invalid type.");
    return false;
  }
  equippedGear[slot] = item;
  log(`Equipped ${item.name} in ${slot} slot.`);
  updateGearUI();
  updateStatsFromGear();
  return true;
}

// Unequip item from slot
function unequipItem(slot) {
  if (!equippedGear[slot]) {
    log(`No item equipped in ${slot} slot.`);
    return false;
  }
  playerInventory.push(equippedGear[slot]);
  equippedGear[slot] = null;
  log(`Unequipped item from ${slot} slot.`);
  updateGearUI();
  updateStatsFromGear();
  return true;
}

// Update player's stats based on gear equipped
function updateStatsFromGear() {
  let weaponAttack = equippedGear.weapon ? equippedGear.weapon.attackBonus : 0;
  let armorDefense = equippedGear.armor ? equippedGear.armor.defenseBonus : 0;
  let accessoryAttack = equippedGear.accessory ? equippedGear.accessory.attackBonus : 0;
  let accessoryDefense = equippedGear.accessory ? equippedGear.accessory.defenseBonus : 0;

  gearAttackBonus = weaponAttack + accessoryAttack;
  gearDefenseBonus = armorDefense + accessoryDefense;

  // Recalculate total attack and defense stats
  totalAttackPower = baseAttackPower + gearAttackBonus + (prestigePoints * 5);
  totalDefensePower = baseDefensePower + gearDefenseBonus + (prestigePoints * 3);

  updateUI();
}

// ======================
// Soldier Formation System
// ======================

// Define formations
const formations = {
  line: 'line',
  wedge: 'wedge',
  square: 'square',
  circle: 'circle'
};

// Current formation
let currentFormation = formations.line;

// Formation bonuses
const formationBonuses = {
  line: { attackMultiplier: 1.0, defenseMultiplier: 1.0 },
  wedge: { attackMultiplier: 1.2, defenseMultiplier: 0.8 },
  square: { attackMultiplier: 0.8, defenseMultiplier: 1.3 },
  circle: { attackMultiplier: 1.0, defenseMultiplier: 1.2 }
};

// Change formation
function changeFormation(formation) {
  if (!formations[formation]) {
    log("Invalid formation.");
    return;
  }
  currentFormation = formation;
  log(`Formation changed to ${formation}.`);
  updateUI();
}

// Get formation multipliers
function getFormationAttackMultiplier() {
  return formationBonuses[currentFormation].attackMultiplier;
}

function getFormationDefenseMultiplier() {
  return formationBonuses[currentFormation].defenseMultiplier;
}

// =====================
// Combat Calculations
// =====================

// Calculate total attack power including gear and formation
function calculateTotalAttackPower() {
  let basePower = baseAttackPower + gearAttackBonus + (prestigePoints * 5);
  let multiplier = getFormationAttackMultiplier();
  return Math.floor(basePower * multiplier);
}

// Calculate total defense power including gear and formation
function calculateTotalDefensePower() {
  let basePower = baseDefensePower + gearDefenseBonus + (prestigePoints * 3);
  let multiplier = getFormationDefenseMultiplier();
  return Math.floor(basePower * multiplier);
}

// Enemy attack modified by player defense
function enemyAttack() {
  if (!currentEnemy) return;
  let baseDamage = currentEnemy.type.attackPower;
  let defense = calculateTotalDefensePower();
  let damageAfterDefense = Math.max(0, baseDamage - defense);
  let damage = damageAfterDefense + Math.floor(Math.random() * 5);

  // Soldiers lost calculation
  let soldiersLost = Math.min(getTotalSoldiers(), Math.floor(damage / 2));
  if (soldiersLost > 0) {
    for (let key in soldierCountByClass) {
      if (soldiersLost <= 0) break;
      let count = soldierCountByClass[key];
      if (count <= 0) continue;
      let removeCount = Math.min(count, soldiersLost);
      soldierCountByClass[key] -= removeCount;
      soldiersLost -= removeCount;
    }
    log(`Enemy attacked! You lost ${Math.floor(damage / 2)} soldiers.`);
    addFeedback(`-${Math.floor(damage / 2)} Soldiers Lost`, 150, 580, 'orange');
  } else {
    log("Enemy attacked but your defense absorbed all damage.");
  }
  updateUI();
}

// =====================
// Inventory UI Updates
// =====================

function updateInventoryUI() {
  const invContainer = document.getElementById('inventoryList');
  if (!invContainer) return;
  invContainer.innerHTML = '';
  if (playerInventory.length === 0) {
    invContainer.textContent = "Inventory is empty.";
    return;
  }
  playerInventory.forEach(item => {
    let div = document.createElement('div');
    div.className = 'inventory-item';
    div.textContent = `${item.name} (${item.rarity})`;
    div.onclick = () => equipItem(item.id);
    invContainer.appendChild(div);
  });
}

// Update equipped gear UI
function updateGearUI() {
  const gearContainer = document.getElementById('equippedGear');
  if (!gearContainer) return;
  gearContainer.innerHTML = '';

  ['weapon', 'armor', 'accessory'].forEach(slot => {
    let item = equippedGear[slot];
    let div = document.createElement('div');
    div.className = 'gear-slot';
    div.textContent = `${slot.toUpperCase()}: ${item ? item.name : 'None'}`;
    if (item) {
      let unequipBtn = document.createElement('button');
      unequipBtn.textContent = 'Unequip';
      unequipBtn.onclick = () => unequipItem(slot);
      div.appendChild(unequipBtn);
    }
    gearContainer.appendChild(div);
  });
}

// Update crafting materials UI
function updateMaterialsUI() {
  const matContainer = document.getElementById('materialsList');
  if (!matContainer) return;
  matContainer.innerHTML = '';
  for (let mat in craftingMaterials) {
    let div = document.createElement('div');
    div.className = 'material-item';
    div.textContent = `${mat}: ${craftingMaterials[mat]}`;
    matContainer.appendChild(div);
  }
}

// ====================
// Item Crafting UI Setup
// ====================

function setupCraftingUI() {
  const craftingContainer = document.getElementById('craftingList');
  if (!craftingContainer) return;
  craftingContainer.innerHTML = '';
  itemDatabase.forEach(item => {
    let div = document.createElement('div');
    div.className = 'crafting-item';
    div.textContent = `${item.name} (${item.rarity}) - Requires: `;

    let reqs = [];
    for (let mat in item.craftingMaterials) {
      reqs.push(`${mat} x${item.craftingMaterials[mat]}`);
    }
    div.textContent += reqs.join(', ');

    let craftBtn = document.createElement('button');
    craftBtn.textContent = "Craft";
    craftBtn.disabled = !canCraft(item);
    craftBtn.onclick = () => {
      if (craftItem(item.id)) {
        craftBtn.disabled = !canCraft(item);
      }
    };

    div.appendChild(craftBtn);
    craftingContainer.appendChild(div);
  });
}

// ====================
// Formation UI Setup
// ====================

function setupFormationUI() {
  const formationContainer = document.getElementById('formationList');
  if (!formationContainer) return;
  formationContainer.innerHTML = '';
  for (let form in formations) {
    let btn = document.createElement('button');
    btn.textContent = form.charAt(0).toUpperCase() + form.slice(1);
    btn.onclick = () => {
      changeFormation(form);
      highlightSelectedFormation(form);
    };
    formationContainer.appendChild(btn);
  }
}

function highlightSelectedFormation(selected) {
  const formationContainer = document.getElementById('formationList');
  if (!formationContainer) return;
  Array.from(formationContainer.children).forEach(btn => {
    btn.style.backgroundColor = btn.textContent.toLowerCase() === selected ? 'lightblue' : '';
  });
}

// ====================
// UI Button Setups
// ====================

function setupItemButtons() {
  setupCraftingUI();
  setupInventoryUI();
  setupGearUI();
  setupMaterialsUI();
  setupFormationUI();
}

function setupInventoryUI() {
  updateInventoryUI();
}

function setupGearUI() {
  updateGearUI();
}

function setupMaterialsUI() {
  updateMaterialsUI();
}

// ====================
// Initialization tweaks
// ====================

function initGame() {
  spawnEnemy(currentEnemyIndex);
  updateUI();
  setupUI();
  setupSoldierClassUI();
  setupItemButtons();
  setupUpgradeButtons();
  log("Game Initialized.");
  highlightSelectedFormation(currentFormation);
}

window.onload = initGame;

// =======================
// Base Stats (defaults)
// =======================

let baseAttackPower = 10;
let baseDefensePower = 5;
let gearAttackBonus = 0;
let gearDefenseBonus = 0;
let totalAttackPower = baseAttackPower;
let totalDefensePower = baseDefensePower;
// ==========================
// Soldier Level & Experience
// ==========================

// Soldier classes experience and levels
let soldierXPByClass = {
  infantry: 0,
  archer: 0,
  cavalry: 0
};

let soldierLevelByClass = {
  infantry: 1,
  archer: 1,
  cavalry: 1
};

// XP required for next level (simple formula)
function getXPForNextLevel(level) {
  return 100 + (level - 1) * 50;
}

// Add XP to soldier class
function addSoldierXP(className, amount) {
  if (!soldierXPByClass.hasOwnProperty(className)) return;
  soldierXPByClass[className] += amount;
  checkSoldierLevelUp(className);
  updateSoldierXPUI(className);
}

// Check if soldier class can level up
function checkSoldierLevelUp(className) {
  let currentXP = soldierXPByClass[className];
  let currentLevel = soldierLevelByClass[className];
  let xpNeeded = getXPForNextLevel(currentLevel);
  while (currentXP >= xpNeeded) {
    soldierLevelByClass[className]++;
    soldierXPByClass[className] -= xpNeeded;
    currentXP = soldierXPByClass[className];
    xpNeeded = getXPForNextLevel(soldierLevelByClass[className]);
    log(`${className.charAt(0).toUpperCase() + className.slice(1)} leveled up to level ${soldierLevelByClass[className]}!`);
    addFeedback(`${className} leveled up!`, 300, 400, 'gold');
    enhanceSoldierStats(className);
  }
}

// Enhance soldier stats on level up
function enhanceSoldierStats(className) {
  switch (className) {
    case 'infantry':
      baseAttackPower += 2;
      baseDefensePower += 3;
      break;
    case 'archer':
      baseAttackPower += 3;
      baseDefensePower += 1;
      break;
    case 'cavalry':
      baseAttackPower += 4;
      baseDefensePower += 2;
      break;
  }
  updateUI();
}

// =======================
// Soldier XP UI Handling
// =======================

function updateSoldierXPUI(className) {
  let xpBar = document.getElementById(`${className}XPBar`);
  let levelLabel = document.getElementById(`${className}LevelLabel`);
  if (!xpBar || !levelLabel) return;

  let currentXP = soldierXPByClass[className];
  let currentLevel = soldierLevelByClass[className];
  let xpNeeded = getXPForNextLevel(currentLevel);

  let percent = Math.min(100, (currentXP / xpNeeded) * 100);
  xpBar.style.width = percent + '%';
  levelLabel.textContent = `Lvl: ${currentLevel}`;
}

// =======================
// Commander Skills System
// =======================

// Skill definitions
const commanderSkills = [
  {
    id: 1,
    name: "Inspire Troops",
    description: "Increases all soldier attack by 10%.",
    levelRequired: 1,
    maxLevel: 5,
    currentLevel: 0,
    attackBonusPerLevel: 0.1,
    defenseBonusPerLevel: 0
  },
  {
    id: 2,
    name: "Shield Wall",
    description: "Increases all soldier defense by 15%.",
    levelRequired: 3,
    maxLevel: 3,
    currentLevel: 0,
    attackBonusPerLevel: 0,
    defenseBonusPerLevel: 0.15
  },
  {
    id: 3,
    name: "Rapid Deployment",
    description: "Decreases soldier training time by 20%.",
    levelRequired: 2,
    maxLevel: 3,
    currentLevel: 0
  }
];

// Player skill points and commander level
let commanderLevel = 1;
let skillPoints = 0;

// Gain skill points on commander level up
function gainSkillPoints(amount) {
  skillPoints += amount;
  updateSkillPointsUI();
}

// Level up commander
function levelUpCommander() {
  commanderLevel++;
  skillPoints += 2;
  log(`Commander leveled up to level ${commanderLevel}! You gained 2 skill points.`);
  updateSkillPointsUI();
  updateCommanderLevelUI();
}

// Upgrade a skill
function upgradeSkill(skillId) {
  let skill = commanderSkills.find(s => s.id === skillId);
  if (!skill) return false;
  if (skill.currentLevel >= skill.maxLevel) {
    log(`${skill.name} is already at max level.`);
    return false;
  }
  if (skill.levelRequired > commanderLevel) {
    log(`Commander level too low to upgrade ${skill.name}.`);
    return false;
  }
  if (skillPoints <= 0) {
    log("Not enough skill points.");
    return false;
  }
  skill.currentLevel++;
  skillPoints--;
  log(`Upgraded skill: ${skill.name} to level ${skill.currentLevel}`);
  updateSkillPointsUI();
  applySkillBonuses();
  updateSkillsUI();
  return true;
}

// Apply skill bonuses to player stats
function applySkillBonuses() {
  let attackMultiplier = 1;
  let defenseMultiplier = 1;
  commanderSkills.forEach(skill => {
    if (skill.currentLevel > 0) {
      attackMultiplier += (skill.attackBonusPerLevel || 0) * skill.currentLevel;
      defenseMultiplier += (skill.defenseBonusPerLevel || 0) * skill.currentLevel;
    }
  });
  totalAttackPower = Math.floor(totalAttackPower * attackMultiplier);
  totalDefensePower = Math.floor(totalDefensePower * defenseMultiplier);
  updateUI();
}

// ==========================
// Skills UI Setup & Update
// ==========================

function setupSkillsUI() {
  const skillsContainer = document.getElementById('skillsList');
  if (!skillsContainer) return;
  skillsContainer.innerHTML = '';

  commanderSkills.forEach(skill => {
    let skillDiv = document.createElement('div');
    skillDiv.className = 'skill-entry';

    let skillName = document.createElement('h4');
    skillName.textContent = skill.name + ` (Lvl ${skill.currentLevel}/${skill.maxLevel})`;
    skillDiv.appendChild(skillName);

    let skillDesc = document.createElement('p');
    skillDesc.textContent = skill.description;
    skillDiv.appendChild(skillDesc);

    let upgradeBtn = document.createElement('button');
    upgradeBtn.textContent = 'Upgrade';
    upgradeBtn.disabled = (skill.currentLevel >= skill.maxLevel || skill.levelRequired > commanderLevel || skillPoints <= 0);
    upgradeBtn.onclick = () => {
      upgradeSkill(skill.id);
      setupSkillsUI(); // Refresh UI after upgrade
    };
    skillDiv.appendChild(upgradeBtn);

    skillsContainer.appendChild(skillDiv);
  });
}

function updateSkillPointsUI() {
  let spLabel = document.getElementById('skillPointsLabel');
  if (!spLabel) return;
  spLabel.textContent = `Skill Points: ${skillPoints}`;
}

function updateCommanderLevelUI() {
  let clLabel = document.getElementById('commanderLevelLabel');
  if (!clLabel) return;
  clLabel.textContent = `Commander Level: ${commanderLevel}`;
}

// ======================
// Enemy Wave & Spawning
// ======================

let enemyWaves = [
  {
    waveNumber: 1,
    enemies: [
      { type: 'grunt', count: 10 },
      { type: 'archer', count: 5 }
    ]
  },
  {
    waveNumber: 2,
    enemies: [
      { type: 'grunt', count: 20 },
      { type: 'archer', count: 10 },
      { type: 'cavalry', count: 3 }
    ]
  },
  {
    waveNumber: 3,
    enemies: [
      { type: 'grunt', count: 30 },
      { type: 'archer', count: 15 },
      { type: 'cavalry', count: 10 },
      { type: 'elite', count: 2 }
    ]
  }
];

let currentWaveIndex = 0;
let activeEnemies = [];

// Enemy definitions
const enemyTypes = {
  grunt: { name: "Grunt", attackPower: 5, defensePower: 3, health: 30 },
  archer: { name: "Enemy Archer", attackPower: 7, defensePower: 2, health: 20 },
  cavalry: { name: "Enemy Cavalry", attackPower: 10, defensePower: 5, health: 50 },
  elite: { name: "Elite Soldier", attackPower: 20, defensePower: 10, health: 100 }
};

// Spawn next wave
function spawnNextWave() {
  if (currentWaveIndex >= enemyWaves.length) {
    log("All waves cleared! You win!");
    addFeedback("Victory!", 400, 300, 'lime');
    return;
  }

  activeEnemies = [];
  let wave = enemyWaves[currentWaveIndex];
  log(`Spawning Wave ${wave.waveNumber}`);

  wave.enemies.forEach(enemyGroup => {
    for (let i = 0; i < enemyGroup.count; i++) {
      let enemyData = enemyTypes[enemyGroup.type];
      if (!enemyData) continue;
      let enemyInstance = {
        id: generateUniqueId(),
        type: enemyGroup.type,
        health: enemyData.health,
        attackPower: enemyData.attackPower,
        defensePower: enemyData.defensePower,
        name: enemyData.name
      };
      activeEnemies.push(enemyInstance);
    }
  });

  currentWaveIndex++;
  updateEnemyUI();
}

// Unique ID generator for enemies
function generateUniqueId() {
  return 'enemy-' + Math.random().toString(36).substr(2, 9);
}

// ====================
// Enemy UI Updates
// ====================

function updateEnemyUI() {
  const enemyContainer = document.getElementById('enemyList');
  if (!enemyContainer) return;

  enemyContainer.innerHTML = '';
  if (activeEnemies.length === 0) {
    enemyContainer.textContent = "No active enemies.";
    return;
  }

  activeEnemies.forEach(enemy => {
    let div = document.createElement('div');
    div.className = 'enemy-entry';
    div.textContent = `${enemy.name} (HP: ${enemy.health})`;
    enemyContainer.appendChild(div);
  });
}

// ====================
// Combat & Enemy Logic
// ====================

// Player attack on enemies
function playerAttack() {
  if (activeEnemies.length === 0) {
    log("No enemies to attack.");
    return;
  }

  let attackPower = calculateTotalAttackPower();
  let target = activeEnemies[0]; // attack first enemy for now

  target.health -= attackPower;
  log(`Attacked ${target.name} for ${attackPower} damage.`);

  if (target.health <= 0) {
    log(`${target.name} defeated!`);
    addFeedback(`+XP`, 300, 350, 'yellow');
    grantXPToSoldiers(10);
    activeEnemies.shift();
  }

  if (activeEnemies.length === 0) {
    log("Wave cleared!");
    addFeedback("Wave Cleared!", 400, 300, 'lime');
    spawnNextWave();
  } else {
    enemyAttack();
  }

  updateEnemyUI();
  updateUI();
}

// Grant XP to all soldier classes after enemy defeat
function grantXPToSoldiers(amount) {
  for (let className in soldierXPByClass) {
    addSoldierXP(className, amount);
  }
}

// ===================
// Save / Load System
// ===================

// Save game state to localStorage
function saveGame() {
  let saveData = {
    playerInventory,
    equippedGear,
    craftingMaterials,
    soldierXPByClass,
    soldierLevelByClass,
    commanderLevel,
    skillPoints,
    commanderSkills,
    currentWaveIndex,
    activeEnemies,
    baseAttackPower,
    baseDefensePower,
    prestigePoints,
    soldierCountByClass
  };

  localStorage.setItem('idleWarCommanderSave', JSON.stringify(saveData));
  log("Game saved.");
}

// Load game state from localStorage
function loadGame() {
  let savedData = localStorage.getItem('idleWarCommanderSave');
  if (!savedData) {
    log("No saved game found.");
    return;
  }
  try {
    let saveData = JSON.parse(savedData);
    playerInventory = saveData.playerInventory || [];
    equippedGear = saveData.equippedGear || { weapon: null, armor: null, accessory: null };
    craftingMaterials = saveData.craftingMaterials || craftingMaterials;
    soldierXPByClass = saveData.soldierXPByClass || soldierXPByClass;
    soldierLevelByClass = saveData.soldierLevelByClass || soldierLevelByClass;
    commanderLevel = saveData.commanderLevel || 1;
    skillPoints = saveData.skillPoints || 0;
    commanderSkills.forEach(skill => {
      let savedSkill = saveData.commanderSkills.find(s => s.id === skill.id);
      if (savedSkill) skill.currentLevel = savedSkill.currentLevel || 0;
    });
    currentWaveIndex = saveData.currentWaveIndex || 0;
    activeEnemies = saveData.activeEnemies || [];
    baseAttackPower = saveData.baseAttackPower || 10;
    baseDefensePower = saveData.baseDefensePower || 5;
    prestigePoints = saveData.prestigePoints || 0;
    soldierCountByClass = saveData.soldierCountByClass || soldierCountByClass;

    log("Game loaded.");
    updateUI();
    updateEnemyUI();
    updateInventoryUI();
    updateGearUI();
    updateMaterialsUI();
    setupSkillsUI();
    updateSkillPointsUI();
    updateCommanderLevelUI();
  } catch (e) {
    log("Failed to load saved game.");
  }
}

// =====================
// UI Setup for Save/Load
// =====================

function setupSaveLoadUI() {
  const saveBtn = document.getElementById('saveGameBtn');
  const loadBtn = document.getElementById('loadGameBtn');
  if (saveBtn) saveBtn.onclick = saveGame;
  if (loadBtn) loadBtn.onclick = loadGame;
}

// ========================
// Setup all UI components
// ========================

function setupUI() {
  setupSoldierClassUI();
  setupItemButtons();
  setupUpgradeButtons();
  setupSkillsUI();
  setupSaveLoadUI();
  setupFormationUI();
  updateUI();
}

// ========================
// Enhanced UI Updates
// ========================

function updateUI() {
  updateSoldierXPUI('infantry');
  updateSoldierXPUI('archer');
  updateSoldierXPUI('cavalry');
  updateInventoryUI();
  updateGearUI();
  updateMaterialsUI();
  updateSkillPointsUI();
  updateCommanderLevelUI();
  updateEnemyUI();
  updateAttackDefenseLabels();
  highlightSelectedFormation(currentFormation);
}

function updateAttackDefenseLabels() {
  const attackLabel = document.getElementById('attackPowerLabel');
  const defenseLabel = document.getElementById('defensePowerLabel');
  if (attackLabel) attackLabel.textContent = `Attack Power: ${totalAttackPower}`;
  if (defenseLabel) defenseLabel.textContent = `Defense Power: ${totalDefensePower}`;
}

// ===================
// Initialization
// ===================

window.onload = () => {
  initGame();
  setupUI();
  log("Game fully loaded.");
};



