<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Idle War Commander - Core</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #121212;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  #gameContainer {
    display: flex;
    height: 100vh;
    width: 100vw;
  }
  #gameCanvas {
    background: #1b1b1b;
    flex: 3;
    display: block;
  }
  #uiPanel {
    flex: 1;
    background: #222;
    padding: 15px;
    box-sizing: border-box;
    overflow-y: auto;
  }
  h1, h2 {
    margin: 0 0 10px 0;
  }
  button {
    width: 100%;
    margin: 6px 0;
    padding: 10px;
    font-size: 1rem;
    background: #3a3a3a;
    border: none;
    color: #eee;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.3s;
  }
  button:hover:not(:disabled) {
    background: #4caf50;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  .stat {
    margin-bottom: 8px;
    font-size: 1.1rem;
  }
  #log {
    margin-top: 20px;
    height: 160px;
    overflow-y: auto;
    background: #111;
    padding: 8px;
    border-radius: 6px;
    font-size: 0.9rem;
    line-height: 1.2;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="uiPanel">
    <h1>Idle War Commander</h1>
    <div class="stat">Soldiers: <span id="soldiersCount">0</span></div>
    <div class="stat">Gold: <span id="goldCount">0</span></div>
    <div class="stat">Enemy Health: <span id="enemyHealth">100</span></div>
    <h2>Actions</h2>
    <button id="attackBtn" disabled>Attack Enemy (-5 Soldiers)</button>
    <button id="recruitBtn">Recruit Soldiers (+1 per 3 sec)</button>
    <h2>Upgrades</h2>
    <button id="upgradeRecruitBtn">Upgrade Recruitment (Cost: 50 Soldiers)</button>
    <button id="upgradeAttackBtn">Upgrade Attack Power (Cost: 75 Soldiers)</button>
    <button id="upgradeGoldBtn">Upgrade Gold Gain (Cost: 30 Gold)</button>
    <h2>Item Shop</h2>
    <button id="buyShieldBtn">Buy Shield (50 Gold)</button>
    <button id="buyMedicBtn">Buy Medic Tent (100 Gold)</button>
    <div id="log"></div>
  </div>
</div>

<script>
// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

// Game State
let soldiers = 0;
let gold = 0;
let enemyHealth = 100;
let maxEnemyHealth = 100;

let recruitRate = 1; // soldiers per interval
let recruitInterval = 3000; // 3 seconds

let attackPower = 10;
let goldGain = 1;

let shieldActive = false;
let medicActive = false;

let upgradeRecruitCost = 50;
let upgradeAttackCost = 75;
let upgradeGoldCost = 30;

// UI Elements
const soldiersCount = document.getElementById('soldiersCount');
const goldCount = document.getElementById('goldCount');
const enemyHealthEl = document.getElementById('enemyHealth');

const attackBtn = document.getElementById('attackBtn');
const recruitBtn = document.getElementById('recruitBtn');
const upgradeRecruitBtn = document.getElementById('upgradeRecruitBtn');
const upgradeAttackBtn = document.getElementById('upgradeAttackBtn');
const upgradeGoldBtn = document.getElementById('upgradeGoldBtn');
const buyShieldBtn = document.getElementById('buyShieldBtn');
const buyMedicBtn = document.getElementById('buyMedicBtn');
const logEl = document.getElementById('log');

// Timing control
let lastRecruitTime = 0;
let lastEnemyAttackTime = 0;
const enemyAttackInterval = 7000; // Enemy attacks roughly every 7 sec

// Animation Frames for soldiers and enemies
const soldierFrames = [];
const enemyFrames = [];
let soldierFrameIndex = 0;
let enemyFrameIndex = 0;

// Load images for animations
function loadImage(src) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.src = src;
  });
}

async function loadAssets() {
  // You can replace these URLs with your own sprites or sprite sheets
  // For now we load 4 frames each for soldiers and enemies for simple animation
  soldierFrames.push(await loadImage('https://i.imgur.com/zG7p3TG.png')); // soldier1
  soldierFrames.push(await loadImage('https://i.imgur.com/ooNxMPh.png')); // soldier2
  soldierFrames.push(await loadImage('https://i.imgur.com/fjFczJF.png')); // soldier3
  soldierFrames.push(await loadImage('https://i.imgur.com/txCZ0no.png')); // soldier4

  enemyFrames.push(await loadImage('https://i.imgur.com/dGkNaPc.png')); // enemy1
  enemyFrames.push(await loadImage('https://i.imgur.com/cvA4L4P.png')); // enemy2
  enemyFrames.push(await loadImage('https://i.imgur.com/t2V0zHf.png')); // enemy3
  enemyFrames.push(await loadImage('https://i.imgur.com/3Uy1cRz.png')); // enemy4
}

// Game Logs
function log(message) {
  const p = document.createElement('p');
  p.textContent = message;
  logEl.prepend(p);
  if (logEl.childNodes.length > 50) {
    logEl.removeChild(logEl.lastChild);
  }
}

// Update UI elements
function updateUI() {
  soldiersCount.textContent = soldiers;
  goldCount.textContent = gold;
  enemyHealthEl.textContent = enemyHealth;
  attackBtn.disabled = soldiers < 5 || enemyHealth <= 0;
  upgradeRecruitBtn.disabled = soldiers < upgradeRecruitCost;
  upgradeAttackBtn.disabled = soldiers < upgradeAttackCost;
  upgradeGoldBtn.disabled = gold < upgradeGoldCost;
  buyShieldBtn.disabled = gold < 50 || shieldActive;
  buyMedicBtn.disabled = gold < 100 || medicActive;
}

// Recruitment
function recruitSoldiers() {
  soldiers += recruitRate;
  log(`Recruited ${recruitRate} soldier(s). Total: ${soldiers}`);
}

// Attack Enemy
function attackEnemy() {
  if (soldiers < 5 || enemyHealth <= 0) return;
  soldiers -= 5;
  enemyHealth -= attackPower;

  log(`Attacked enemy for ${attackPower} damage. Enemy health: ${Math.max(enemyHealth, 0)}`);

  if (enemyHealth <= 0) {
    enemyHealth = 0;
    soldiers += 50;
    gold += 10 * goldGain;
    log(`Enemy defeated! Gained 50 soldiers and ${10 * goldGain} gold.`);
    enemyHealth = maxEnemyHealth;
  }

  updateUI();
}

// Enemy Attacks Soldiers
function enemyAttack() {
  if (soldiers <= 0) {
    log('Enemy attacks but you have no soldiers left!');
    return;
  }

  if (shieldActive) {
    shieldActive = false;
    log('Shield absorbed the enemy attack!');
    return;
  }

  let damage = Math.min(soldiers, Math.floor(Math.random() * 15) + 5);
  soldiers -= damage;
  log(`Enemy attacked! Lost ${damage} soldiers.`);

  if (medicActive) {
    let heal = Math.min(5, 100 - soldiers);
    soldiers += heal;
    log(`Medic Tent healed ${heal} soldiers.`);
  }

  updateUI();
}

// Upgrades
function upgradeRecruit() {
  if (soldiers >= upgradeRecruitCost) {
    soldiers -= upgradeRecruitCost;
    recruitRate++;
    upgradeRecruitCost = Math.floor(upgradeRecruitCost * 1.7);
    log('Recruitment rate upgraded!');
    updateUI();
  }
}

function upgradeAttack() {
  if (soldiers >= upgradeAttackCost) {
    soldiers -= upgradeAttackCost;
    attackPower += 5;
    upgradeAttackCost = Math.floor(upgradeAttackCost * 1.8);
    log('Attack power upgraded!');
    updateUI();
  }
}

function upgradeGold() {
  if (gold >= upgradeGoldCost) {
    gold -= upgradeGoldCost;
    goldGain++;
    upgradeGoldCost = Math.floor(upgradeGoldCost * 1.5);
    log('Gold gain upgraded!');
    updateUI();
  }
}

// Buy items
function buyShield() {
  if (gold >= 50 && !shieldActive) {
    gold -= 50;
    shieldActive = true;
    log('Shield purchased and activated!');
    updateUI();
  }
}

function buyMedic() {
  if (gold >= 100 && !medicActive) {
    gold -= 100;
    medicActive = true;
    log('Medic Tent purchased! Soldiers will heal after attacks.');
    updateUI();
  }
}

// Game Loop
let lastFrameTime = 0;
function gameLoop(timestamp) {
  if (!lastFrameTime) lastFrameTime = timestamp;
  let delta = timestamp - lastFrameTime;

  // Recruitment timing
  if (timestamp - lastRecruitTime > recruitInterval) {
    recruitSoldiers();
    lastRecruitTime = timestamp;
  }

  // Enemy attack timing
  if (timestamp - lastEnemyAttackTime > enemyAttackInterval) {
    enemyAttack();
    lastEnemy
// --- Continuation from previous code ---

  lastEnemyAttackTime = timestamp;
  }

  // Clear canvas for redraw
  ctx.clearRect(0, 0, width, height);

  // Draw background battlefield (simple grid)
  drawBattlefield();

  // Draw soldiers animation
  drawSoldiers();

  // Draw enemy animation
  drawEnemy();

  // Draw UI overlays or effects if needed
  drawEffects();

  // Update frame indices for animation
  updateAnimationFrames(delta);

  lastFrameTime = timestamp;
  requestAnimationFrame(gameLoop);
}

// Draw battlefield grid pattern
function drawBattlefield() {
  ctx.fillStyle = '#2a2a2a';
  ctx.fillRect(0, 0, width, height);

  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  const gridSize = 40;
  for(let x = 0; x < width; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, height);
    ctx.stroke();
  }
  for(let y = 0; y < height; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(width, y);
    ctx.stroke();
  }
}

// Draw soldiers sprites in formation on left side
function drawSoldiers() {
  const cols = 8;
  const spacingX = 50;
  const spacingY = 55;
  const startX = 50;
  const startY = height - 250;

  // Calculate how many soldiers to draw (max 40 for performance)
  const drawCount = Math.min(soldiers, 40);
  let frame = soldierFrames[soldierFrameIndex];

  for (let i = 0; i < drawCount; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    let x = startX + col * spacingX;
    let y = startY - row * spacingY;

    // Simple bobbing animation by offsetting y slightly based on frame
    let bobOffset = Math.sin(Date.now() / 200 + i) * 3;
    ctx.drawImage(frame, x, y + bobOffset, 40, 40);
  }
}

// Draw enemy sprites on right side with health bar
function drawEnemy() {
  const enemyX = width - 150;
  const enemyY = height - 280;
  let frame = enemyFrames[enemyFrameIndex];

  ctx.drawImage(frame, enemyX, enemyY, 80, 80);

  // Draw enemy health bar above enemy
  const barWidth = 120;
  const barHeight = 15;
  const healthRatio = enemyHealth / maxEnemyHealth;

  // Background bar
  ctx.fillStyle = '#550000';
  ctx.fillRect(enemyX - 20, enemyY - 25, barWidth, barHeight);

  // Health bar fill
  ctx.fillStyle = '#ff4444';
  ctx.fillRect(enemyX - 20, enemyY - 25, barWidth * healthRatio, barHeight);

  // Border
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(enemyX - 20, enemyY - 25, barWidth, barHeight);
}

// Optional visual effects placeholder
function drawEffects() {
  // For future flashes, explosions, or shield effect
  if (shieldActive) {
    // Draw glowing shield circle around soldiers
    ctx.save();
    ctx.strokeStyle = 'rgba(50, 200, 50, 0.7)';
    ctx.lineWidth = 6;
    ctx.shadowColor = '#0f0';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.ellipse(250, height - 170, 120, 80, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

// Animate frame cycling for soldiers and enemies
function updateAnimationFrames(delta) {
  // Change frames every 200ms
  if (!updateAnimationFrames.lastUpdate) updateAnimationFrames.lastUpdate = 0;

  updateAnimationFrames.lastUpdate += delta;
  if (updateAnimationFrames.lastUpdate > 200) {
    soldierFrameIndex = (soldierFrameIndex + 1) % soldierFrames.length;
    enemyFrameIndex = (enemyFrameIndex + 1) % enemyFrames.length;
    updateAnimationFrames.lastUpdate = 0;
  }
}

// Event listeners for buttons

attackBtn.addEventListener('click', () => {
  attackEnemy();
});

recruitBtn.addEventListener('click', () => {
  // Optional manual recruit +1
  soldiers++;
  log('Manually recruited 1 soldier.');
  updateUI();
});

upgradeRecruitBtn.addEventListener('click', () => {
  upgradeRecruit();
});

upgradeAttackBtn.addEventListener('click', () => {
  upgradeAttack();
});

upgradeGoldBtn.addEventListener('click', () => {
  upgradeGold();
});

buyShieldBtn.addEventListener('click', () => {
  buyShield();
});

buyMedicBtn.addEventListener('click', () => {
  buyMedic();
});

// Reset Game Button (added dynamically)
const resetBtn = document.createElement('button');
resetBtn.textContent = 'Reset Game';
resetBtn.style.marginTop = '20px';
resetBtn.style.background = '#cc4444';
resetBtn.style.color = '#fff';
resetBtn.addEventListener('click', () => {
  if(confirm('Are you sure you want to reset the game? All progress will be lost.')) {
    resetGame();
  }
});
document.getElementById('uiPanel').appendChild(resetBtn);

// Reset game function
function resetGame() {
  soldiers = 0;
  gold = 0;
  enemyHealth = maxEnemyHealth;
  recruitRate = 1;
  attackPower = 10;
  goldGain = 1;
  shieldActive = false;
  medicActive = false;
  upgradeRecruitCost = 50;
  upgradeAttackCost = 75;
  upgradeGoldCost = 30;
  logEl.innerHTML = '';
  log('Game reset.');
  updateUI();
}

// Initialize game assets then start
loadAssets().then(() => {
  log('Assets loaded. Starting game...');
  updateUI();
  enemyHealth = maxEnemyHealth;
  requestAnimationFrame(gameLoop);
}).catch(e => {
  log('Error loading assets: ' + e.message);
  alert('Failed to load game assets. Please refresh.');
});
// --- Extended game variables for advanced features ---

const enemyTypes = [
  {
    name: 'Goblin',
    maxHealth: 100,
    attackPower: 5,
    spriteUrls: [
      'https://i.imgur.com/QIGfVQa.gif',  // idle frames placeholder
      'https://i.imgur.com/zZQbC0U.gif',
    ],
  },
  {
    name: 'Orc',
    maxHealth: 300,
    attackPower: 15,
    spriteUrls: [
      'https://i.imgur.com/2M9aMgz.gif', // orc idle frame 1
      'https://i.imgur.com/Fo3XtNv.gif', // orc idle frame 2
    ],
  },
  {
    name: 'Troll',
    maxHealth: 800,
    attackPower: 40,
    spriteUrls: [
      'https://i.imgur.com/LU44Wjp.gif', // troll idle frame 1
      'https://i.imgur.com/R14tLJS.gif', // troll idle frame 2
    ],
  }
];

// Soldier classes with stats and images
const soldierClasses = {
  infantry: {
    name: 'Infantry',
    baseAttack: 10,
    baseDefense: 10,
    recruitCost: 1,  // soldiers needed to recruit 1 infantry
    spriteUrls: [
      'https://i.imgur.com/5W9kSfs.gif',
      'https://i.imgur.com/5W9kSfs2.gif',
    ]
  },
  archer: {
    name: 'Archer',
    baseAttack: 15,
    baseDefense: 5,
    recruitCost: 3,
    spriteUrls: [
      'https://i.imgur.com/BV06O9h.gif',
      'https://i.imgur.com/BV06O9h2.gif',
    ]
  },
  cavalry: {
    name: 'Cavalry',
    baseAttack: 25,
    baseDefense: 15,
    recruitCost: 5,
    spriteUrls: [
      'https://i.imgur.com/GFk73ro.gif',
      'https://i.imgur.com/GFk73ro2.gif',
    ]
  }
};

let currentEnemyIndex = 0;
let currentEnemy = null;

let soldierCountByClass = {
  infantry: 0,
  archer: 0,
  cavalry: 0,
};

let soldierSprites = {};
let enemySprites = [];

let recruitQueue = [];  // queue for soldiers to recruit over time

// Item system
const items = {
  shield: {
    name: 'Shield',
    costGold: 50,
    cooldownMs: 30000,
    active: false,
    lastUsed: 0,
    effect: function() {
      shieldActive = true;
      log('Shield activated! Next enemy attack absorbed.');
    }
  },
  medicTent: {
    name: 'Medic Tent',
    costGold: 100,
    cooldownMs: 60000,
    active: false,
    lastUsed: 0,
    effect: function() {
      medicActive = true;
      log('Medic tent deployed. Healing soldiers over time.');
    }
  }
};

// Save/load keys
const saveKey = 'idleWarCommanderSave';

// Initialize enemy sprites cache
async function loadEnemySprites() {
  for(let enemy of enemyTypes) {
    enemy.sprites = [];
    for(let url of enemy.spriteUrls) {
      const img = await loadImage(url);
      enemy.sprites.push(img);
    }
  }
}

// Initialize soldier sprites cache
async function loadSoldierSprites() {
  for(let key in soldierClasses) {
    soldierClasses[key].sprites = [];
    for(let url of soldierClasses[key].spriteUrls) {
      const img = await loadImage(url);
      soldierClasses[key].sprites.push(img);
    }
  }
}

// Helper function to load image
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error('Failed to load image: ' + src));
    img.src = src;
  });
}

// Spawn enemy function
function spawnEnemy(index) {
  currentEnemyIndex = index;
  currentEnemy = {
    type: enemyTypes[index],
    health: enemyTypes[index].maxHealth,
    maxHealth: enemyTypes[index].maxHealth,
    attackPower: enemyTypes[index].attackPower,
    frameIndex: 0,
    frameElapsed: 0,
  };
  enemyFrames = currentEnemy.type.sprites;
  enemyFrameIndex = 0;
  maxEnemyHealth = currentEnemy.maxHealth;
  log(`Enemy Spawned: ${currentEnemy.type.name} (HP: ${currentEnemy.maxHealth})`);
}

// Recruit soldier class function (queues recruitment)
function recruitSoldierClass(className, amount = 1) {
  if (!soldierClasses[className]) return false;
  let cost = soldierClasses[className].recruitCost * amount;
  if (soldiers < cost) {
    log(`Not enough soldiers to recruit ${amount} ${className}(s).`);
    return false;
  }
  soldiers -= cost;
  for(let i = 0; i < amount; i++) {
    recruitQueue.push(className);
  }
  log(`Queued recruitment of ${amount} ${className}(s).`);
  updateUI();
  return true;
}

// Process recruit queue gradually
function processRecruitQueue() {
  if (recruitQueue.length > 0) {
    // Recruit 1 soldier per tick
    let className = recruitQueue.shift();
    soldierCountByClass[className]++;
    log(`Recruited 1 ${className}. Total: ${soldierCountByClass[className]}`);
    updateUI();
  }
}

// Calculate total soldier attack power dynamically
function calculateTotalAttackPower() {
  let total = 0;
  for(let key in soldierCountByClass) {
    total += soldierCountByClass[key] * soldierClasses[key].baseAttack;
  }
  return total + attackPower;
}

// Enemy AI attack
function enemyAttack() {
  if (!currentEnemy) return;

  let now = Date.now();
  if (now - lastEnemyAttackTime < 3000) return; // 3 sec cooldown

  lastEnemyAttackTime = now;

  if (shieldActive) {
    shieldActive = false;
    log('Shield absorbed enemy attack!');
    return;
  }

  // Calculate damage to soldiers
  let damage = currentEnemy.attackPower;

  // Simple defense: subtract average soldier defense
  let totalDefense = 0;
  for(let key in soldierCountByClass) {
    totalDefense += soldierCountByClass[key] * soldierClasses[key].baseDefense;
  }
  let totalSoldiers = Object.values(soldierCountByClass).reduce((a,b)=>a+b,0);

  let avgDefense = totalSoldiers > 0 ? totalDefense / totalSoldiers : 0;
  let netDamage = Math.max(0, damage - avgDefense);

  if (netDamage > 0 && totalSoldiers > 0) {
    // Remove soldiers proportionally from classes
    for(let key in soldierCountByClass) {
      if (soldierCountByClass[key] > 0) {
        let loss = Math.min(soldierCountByClass[key], Math.ceil(netDamage * soldierCountByClass[key] / totalSoldiers));
        soldierCountByClass[key] -= loss;
        log(`Enemy attack! Lost ${loss} ${key}(s).`);
      }
    }
  } else {
    log('Enemy attack blocked by soldier defenses.');
  }

  updateUI();
}

// Player attacks enemy
function playerAttack() {
  let totalAttack = calculateTotalAttackPower();

  currentEnemy.health -= totalAttack;

  log(`You attacked enemy for ${totalAttack} damage!`);

  if (currentEnemy.health <= 0) {
    enemyDefeated();
  }

  updateUI();
}

// Enemy defeated handler
function enemyDefeated() {
  log(`Enemy ${currentEnemy.type.name} defeated!`);
  gold += currentEnemy.type.maxHealth / 10 * goldGain;
  soldiers += 10 * recruitRate;

  // Advance to next enemy or loop back
  currentEnemyIndex++;
  if (currentEnemyIndex >= enemyTypes.length) {
    currentEnemyIndex = 0;
  }
  spawnEnemy(currentEnemyIndex);
  updateUI();
}

// Item purchase handler
function buyItem(itemName) {
  if (!items[itemName]) return;
  let item = items[itemName];
  if (gold < item.costGold) {
    log(`Not enough gold to buy ${item.name}.`);
    return false;
  }
  if (Date.now() - item.lastUsed < item.cooldownMs) {
    log(`${item.name} is on cooldown.`);
    return false;
  }
  gold -= item.costGold;
  item.lastUsed = Date.now();
  item.effect();
  updateUI();
  return true;
}

// Save game state to localStorage
function saveGame() {
  let state = {
    soldiers,
    soldierCountByClass,
    gold,
    currentEnemyIndex,
    currentEnemyHealth: currentEnemy ? currentEnemy.health : maxEnemyHealth,
    recruitRate,
    attackPower,
    goldGain,
    shieldActive,
    medicActive,
    recruitQueue,
    lastSave: Date.now(),
  };
  localStorage.setItem(saveKey, JSON.stringify(state));
  log('Game saved.');
}

// Load game state from localStorage
function loadGame() {
  let stateStr = localStorage.getItem(saveKey);
  if (!stateStr) {
    log('No saved game found.');
    return false;
  }
  try {
    let state = JSON.parse(stateStr);
    soldiers = state.soldiers || 0;
    soldierCountByClass = state.soldierCountByClass || { infantry:0, archer:0, cavalry:0 };
    gold = state.gold || 0;
    currentEnemyIndex = state.currentEnemyIndex || 0;
    recruitRate = state.recruitRate || 1;
    attackPower = state.attackPower || 10;
    goldGain = state.goldGain || 1;
    shieldActive = state.shieldActive || false;
    medicActive = state.medicActive || false;
    recruitQueue = state.recruitQueue || [];
    spawnEnemy(currentEnemyIndex);
    currentEnemy.health = state.currentEnemyHealth || currentEnemy.maxHealth;
    updateUI();
    log('Game loaded.');
    return true;
  } catch (e) {
    log('Failed to load saved game.');
    return false;
  }
}

// Game tick to update state every 5 seconds
function gameTick() {
  soldiers += recruitRate;
  if (medicActive) {
    soldiers += 2; // Medic heals 2 soldiers per tick
    log('Medic healed 2 soldiers.');
  }
  processRecruitQueue();
  enemyAttack();

  saveGame();

  updateUI();
}

// Set game tick interval
setInterval(gameTick, recruitIntervalMs);

// UI Setup for soldier classes recruit buttons
function setupSoldierClassUI() {
  const container = document.getElementById('soldierClassButtons');
  if (!container) return;
  container.innerHTML = ''; // clear existing buttons

  for (let key in soldierClasses) {
    const btn = document.createElement('button');
    btn.textContent = `Recruit ${soldierClasses[key].name} (Cost: ${soldierClasses[key
// --- Continuing soldier recruit buttons creation ---

    recruitCost})`;
    btn.onclick = () => {
      recruitSoldierClass(key, 1);
    };
    container.appendChild(btn);
  }
}

// Animate enemy sprite frames for idle animation
function animateEnemySprite(deltaTime) {
  if (!currentEnemy) return;
  currentEnemy.frameElapsed += deltaTime;
  if (currentEnemy.frameElapsed > 500) { // switch frame every 0.5 seconds
    currentEnemy.frameIndex = (currentEnemy.frameIndex + 1) % currentEnemy.type.sprites.length;
    currentEnemy.frameElapsed = 0;
  }
}

// Animate soldier sprites for idle animation
function animateSoldierSprites(deltaTime) {
  for (let key in soldierCountByClass) {
    if (!soldierClasses[key].frameElapsed) soldierClasses[key].frameElapsed = 0;
    if (!soldierClasses[key].frameIndex) soldierClasses[key].frameIndex = 0;
    soldierClasses[key].frameElapsed += deltaTime;
    if (soldierClasses[key].frameElapsed > 700) { // switch frame every 0.7 seconds
      soldierClasses[key].frameIndex = (soldierClasses[key].frameIndex + 1) % soldierClasses[key].sprites.length;
      soldierClasses[key].frameElapsed = 0;
    }
  }
}

// Draw function to render game elements on canvas
function drawGame() {
  const canvas = document.getElementById('gameCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw enemy
  if (currentEnemy && currentEnemy.type.sprites.length > 0) {
    let sprite = currentEnemy.type.sprites[currentEnemy.frameIndex];
    ctx.drawImage(sprite, canvas.width/2 - sprite.width/2, 50);
  }

  // Draw enemy health bar
  if (currentEnemy) {
    const barWidth = 300;
    const barHeight = 20;
    const x = canvas.width/2 - barWidth/2;
    const y = 20;

    ctx.fillStyle = 'gray';
    ctx.fillRect(x, y, barWidth, barHeight);

    const healthPercent = Math.max(0, currentEnemy.health / currentEnemy.maxHealth);
    ctx.fillStyle = 'red';
    ctx.fillRect(x, y, barWidth * healthPercent, barHeight);

    ctx.strokeStyle = 'black';
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.fillText(`${currentEnemy.type.name} HP: ${Math.floor(currentEnemy.health)} / ${currentEnemy.maxHealth}`, x + 10, y + 15);
  }

  // Draw soldiers count and sprites
  let baseY = canvas.height - 150;
  let startX = 50;
  let spacingX = 150;
  let idx = 0;
  ctx.font = '18px Arial';

  for (let key in soldierCountByClass) {
    let count = soldierCountByClass[key];
    if (count > 0 && soldierClasses[key].sprites.length > 0) {
      let spriteIndex = soldierClasses[key].frameIndex || 0;
      let sprite = soldierClasses[key].sprites[spriteIndex];
      let x = startX + spacingX * idx;
      let y = baseY;

      ctx.drawImage(sprite, x, y);

      ctx.fillStyle = 'black';
      ctx.fillText(`${soldierClasses[key].name}: ${count}`, x, y + sprite.height + 20);
    }
    idx++;
  }

  // Draw gold and soldiers text
  ctx.fillStyle = 'black';
  ctx.font = '22px Arial';
  ctx.fillText(`Gold: ${Math.floor(gold)}`, 20, 40);
  ctx.fillText(`Soldiers (total): ${getTotalSoldiers()}`, 20, 70);

  // Draw recruit queue
  ctx.font = '16px Arial';
  ctx.fillStyle = 'darkblue';
  ctx.fillText(`Recruit Queue: ${recruitQueue.length}`, 20, 100);

  // Draw item cooldowns
  let itemX = canvas.width - 150;
  let itemY = 40;
  for (let key in items) {
    let item = items[key];
    ctx.fillStyle = 'black';
    ctx.fillText(`${item.name}`, itemX, itemY);

    let cooldownLeft = Math.max(0, item.cooldownMs - (Date.now() - item.lastUsed));
    if (cooldownLeft > 0) {
      ctx.fillStyle = 'red';
      ctx.fillText(`Cooldown: ${(cooldownLeft / 1000).toFixed(1)}s`, itemX, itemY + 20);
    } else {
      ctx.fillStyle = 'green';
      ctx.fillText(`Ready!`, itemX, itemY + 20);
    }

    itemY += 50;
  }
}

// Helper to get total soldiers count
function getTotalSoldiers() {
  return Object.values(soldierCountByClass).reduce((a, b) => a + b, 0);
}

// Game loop using requestAnimationFrame
let lastTime = 0;
function gameLoop(time = 0) {
  const deltaTime = time - lastTime;
  lastTime = time;

  animateEnemySprite(deltaTime);
  animateSoldierSprites(deltaTime);
  drawGame();

  requestAnimationFrame(gameLoop);
}

// Start game loop
requestAnimationFrame(gameLoop);

// Log messages to a dedicated UI element
function log(message) {
  const logArea = document.getElementById('logArea');
  if (!logArea) return;
  let p = document.createElement('p');
  p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
  logArea.appendChild(p);
  logArea.scrollTop = logArea.scrollHeight;
}

// Setup item purchase buttons UI
function setupItemButtons() {
  const container = document.getElementById('itemButtons');
  if (!container) return;
  container.innerHTML = '';
  for (let key in items) {
    let item = items[key];
    let btn = document.createElement('button');
    btn.textContent = `Buy ${item.name} (${item.costGold} gold)`;
    btn.onclick = () => buyItem(key);
    container.appendChild(btn);
  }
}

// Upgrade system - simple upgrades for attackPower, recruitRate, goldGain

const upgrades = {
  attackPower: {
    level: 0,
    baseCost: 100,
    increment: 20,
    maxLevel: 10,
    applyUpgrade: () => {
      attackPower += 5;
    }
  },
  recruitRate: {
    level: 0,
    baseCost: 150,
    increment: 30,
    maxLevel: 10,
    applyUpgrade: () => {
      recruitRate += 1;
    }
  },
  goldGain: {
    level: 0,
    baseCost: 120,
    increment: 25,
    maxLevel: 10,
    applyUpgrade: () => {
      goldGain += 0.5;
    }
  }
};

// Purchase upgrade function
function buyUpgrade(upgradeKey) {
  let upg = upgrades[upgradeKey];
  if (!upg) return false;
  if (upg.level >= upg.maxLevel) {
    log(`${upgradeKey} upgrade is maxed out.`);
    return false;
  }
  let cost = upg.baseCost + upg.level * upg.increment;
  if (gold < cost) {
    log(`Not enough gold to upgrade ${upgradeKey}. Need ${cost} gold.`);
    return false;
  }
  gold -= cost;
  upg.level++;
  upg.applyUpgrade();
  log(`Upgraded ${upgradeKey} to level ${upg.level}.`);
  updateUI();
  return true;
}

// Setup upgrade buttons UI
function setupUpgradeButtons() {
  const container = document.getElementById('upgradeButtons');
  if (!container) return;
  container.innerHTML = '';

  for (let key in upgrades) {
    let upg = upgrades[key];
    let btn = document.createElement('button');
    let cost = upg.baseCost + upg.level * upg.increment;
    btn.textContent = `${key} Upgrade (Lvl ${upg.level}) - Cost: ${cost} gold`;
    btn.onclick = () => buyUpgrade(key);
    container.appendChild(btn);
  }
}

// Update UI elements with current game data
function updateUI() {
  // Update soldiers total display
  const soldierCountText = document.getElementById('soldierCountText');
  if (soldierCountText) soldierCountText.textContent = `Soldiers: ${getTotalSoldiers()}`;

  // Update gold display
  const goldCountText = document.getElementById('goldCountText');
  if (goldCountText) goldCountText.textContent = `Gold: ${Math.floor(gold)}`;

  // Update recruit queue count
  const recruitQueueText = document.getElementById('recruitQueueText');
  if (recruitQueueText) recruitQueueText.textContent = `Recruit Queue: ${recruitQueue.length}`;

  // Update upgrade buttons UI cost and labels
  setupUpgradeButtons();
}

// Attach UI button handlers for player attack and recruit soldier mass
document.getElementById('attackEnemyBtn').onclick = playerAttack;
document.getElementById('recruitInfantryBtn').onclick = () => recruitSoldierClass('infantry', 5);
document.getElementById('recruitArcherBtn').onclick = () => recruitSoldierClass('archer', 3);
document.getElementById('recruitCavalryBtn').onclick = () => recruitSoldierClass('cavalry', 2);

setupSoldierClassUI();
setupItemButtons();
setupUpgradeButtons();

spawnEnemy(currentEnemyIndex);
updateUI();

// Sound effects - placeholder
const soundEffects = {
  attack: new Audio('https://actions.google.com/sounds/v1/impacts/metal_thud_and_wood_plank.ogg'),
  enemyDefeated: new Audio('https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg'),
  recruit: new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg')
};

function playSound(name) {
  if (soundEffects[name]) {
    soundEffects[name].currentTime = 0;
    soundEffects[name].play();
  }
}

// Override playerAttack to play sound
function playerAttack() {
  let totalAttack = calculateTotalAttackPower();

  if (!currentEnemy) return;

  currentEnemy.health -= totalAttack;
  log(`You attacked enemy for ${totalAttack} damage!`);
  playSound('attack');

  if (currentEnemy.health <= 0) {
    playSound('enemyDefeated');
    enemyDefeated();
  }

  updateUI();
}

// Override recruitSoldierClass to play recruit sound
function recruitSoldierClass(className, amount = 1) {
  if (!soldierClasses[className]) return false;
  let cost = soldierClasses[className].recruitCost * amount;
  if (soldiers < cost) {
    log(`Not enough soldiers to recruit ${amount} ${className}(s).`);
    return false;
  }
  soldiers -= cost;
  for(let i = 0; i < amount; i++) {
    recruitQueue.push(className);
  }
  log(`Queued recruitment of ${amount} ${className}(s).`);
  playSound('recruit');
  updateUI();
  return true;
}

// Initialize save/load buttons UI and handlers
document.getElementById('saveGameBtn').onclick = saveGame;
document.getElementById('loadGameBtn').onclick = loadGame;


